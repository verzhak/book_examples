
/* Утилита копирования файлов
 *
 * Формат запуска:
 *		
 *		./program.out SRC DEST
 *
 *		Где:
 *
 *			SRC  - путь (относительный или абсолютный) и имя копируемого файла
 *			DEST - путь (относительный или абсолютный) и имя результирующего файла
 *			       (не должен существовать на момент копирования)
 *
 */

#include <stdio.h>

#include <unistd.h>		/* Для read(), write(), close() и fstat() */
#include <sys/types.h>	/* Для open() */
#include <sys/stat.h>
#include <fcntl.h>

int main(const int argv, const char *argc[])
{
	/* Проверяем количество переданных в программу аргументов - если меньше трех (считая имя исполняемого файла), то ошибка */
	if(argv != 3)
	{
		fprintf(stderr, "\nОшибка - некорректное количество аргументов!\nКопирование файлов:\n\t./program.out SRC DEST\n\n");
		fprintf(stderr,"\tSRC  - путь (относительный или абсолютный) и имя исходного файла\n");
		fprintf(stderr,"\tDEST - путь (относительный или абсолютный) и имя результирующего файла (не должен существовать на момент копирования)\n\n");

		return -1;
	}

	printf("\n");

	struct stat st;

	/* Открываем копируемый файл на чтение */
	int src_fd = open(argc[1], O_RDONLY);

	if(
		src_fd == -1
	  )
	{
		perror("Ошибка при открытии копируемого файла");
		printf("\n");

		return -1;
	}
	else if(
			/* С помощью функции fstat() получаем маску прав доступа к копируемому файлу (поле st_mode
			 * структуры данных stat) с тем, чтобы сохранить ее на результирующем файле */
			fstat(src_fd, & st) == -1
		   )
	{
		perror("Ошибка при получении информации о копируемом файле");
		printf("\n");

		close(src_fd);

		return -1;
	}

	/* Создаем (O_CREAT) и открываем результирующий файл на запись (O_WRONLY)
	 * (если файл существует, то данный вызов завершится ошибкой (O_EXCL) - перезапись
	 * файла нам не нужна; маска прав доступа на создаваемый файл - st.st_mode;
	 * владелец и группа пользователей файла совпадают с действительными владельцем
	 * и группой пользователей процесса) */
	int dest_fd = open(argc[2], O_WRONLY | O_CREAT | O_EXCL, st.st_mode);

	if(
		dest_fd == -1
	  )
	{
		perror("Ошибка при создании результирующего файла");
		printf("\n");

		close(src_fd);

		return -1;
	}

	/* Будем читать и записывать данные блоками по 4096 байт, что кратно размеру блока и,
	 * в большинстве случаев, совпадает с размером блока (кластера) в ФС - таким образом,
	 * сделаем попытку достигнуть максимальной производительности копирования */
	#define BUF_SIZE 4096
	char buf[BUF_SIZE];
	unsigned long sum_sz = 0;

	/* Читаем первый блок данных */
	ssize_t write_sz = 1, read_sz = read(src_fd, buf, BUF_SIZE);

	/* Пока в копируемом файле есть данные (read_sz), а запись в результирующий файл
	 * идет без ошибок (write_sz > 0) - копировать очередной 4096-и байтовый блок */
	while(read_sz > 0 && write_sz > 0)
	{
		/* Записываем очередной блок данных в результирующий файл */
		write_sz = write(dest_fd, buf, read_sz);
		sum_sz += write_sz;

		printf("Считано: %d байт, записано: %d байт\n", read_sz, write_sz);

		/* Читаем очередной блок данных из копируемого файла */
		read_sz = read(src_fd, buf, BUF_SIZE);
	}

	/* Закрываем файловые дескрипторы копируемого и результирующего файлов */
	close(src_fd);
	close(dest_fd);

	printf("Всего скопировано: %lu байт = %.3f килобайт = %.3f мегабайт\n\n", sum_sz, sum_sz / 1024.0, sum_sz / (1024.0 * 1024.0));

	return 0;
}

