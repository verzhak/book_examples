
/* Низкоуровневая (на уровне структуры файловой системы) работа с логическими разделами, хранение данных на которых организовано с помощью
 * файловых систем ext2 / ext3
 *
 * Функционал, используемый программой:
 *
 *        - Файл логического раздела (пользователь, запустивший программу, должен иметь право чтения данного файла)
 *        - Системные вызовы open, pread64 и close
 *        - Заголовочный файл <linux/ext2_fs.h> с описаниями структур суперблока, дескриптора группы дескрипторов, inode и дескриптора dentry
 *
 * Задачи, решаемые программой:
 *
 *        1. Вывод в стандартный поток вывода содержимого полей суперблока
 *
 *           Формат запуска:
 *
 *                ./program.out FS
 *
 *                    FS - путь (относительный или абсолютный) и имя файла целевого логического раздела
 *
 *           Реализация:
 *
 *                Функция read_superblock()    -  чтение суперблока
 *                
 *                Функция print_superblock()   -  вывод в стандартный поток вывода содержимого полей суперблока
 *
 *        2. Вывод в стандартный поток вывода содержимого некоторого регулярного (обычного) файла целевой файловой системы
 *
 *           Формат запуска:
 *
 *                ./program.out FS FILE
 *
 *                    FS - путь (относительный или абсолютный) и имя файла целевого логического раздела
 *
 *                    FILE - абсолютный путь от корневого каталога логического раздела и имя целевого файла
 *
 *            Реализация:
 *
 *                Функция read_superblock()   -   чтение суперблока
 *
 *                Функция read_object()       -   чтение содержимого некоторого объекта файловой системы в буфер, указатель на который передан в функцию
 *
 *                Функция print_file()        -   поиск файла по абсолютному пути и имени, считывание содержимого файла в буфер,
 *                                                вывод содержимого файла в стандартный поток вывода
 *
 *            Ограничения:
 *
 *                В функции read_object() отсутствует поддержка двойной и тройной косвенной адресации => не могут быть обработаны объекты файловой системы
 *                размером свыше 4144 килобайта (при размере блока в 4 килобайта)
 */

#define _GNU_SOURCE               /* Для pread64(), dprintf(), O_LARGEFILE */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <errno.h>                /* Для errno */
#include <sys/types.h>            /* Для open() */
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>               /* Для pread64(), close() */
#include <sys/mman.h>             /* Для mmap() и munmap() */
#include <time.h>                 /* Для ctime() */

#include <linux/fs.h>
#include <linux/ext2_fs.h>        /* Для ext2_super_block, ext2_group_desc, ext2_inode, ext2_dir_entry_2, <linux/magic.h> */

/* Функция read_superblock() возвращает указатель на экземпляр структуры данных ext2_super_block, содержащий описатель суперблока файловой системы,
 * номер файлового дескриптора открытого файла логического раздела которой передан параметром dev_fd */
struct ext2_super_block *read_superblock(int dev_fd);

/* Функция print_superblock() выводит в стандартный поток вывода содержимое полей суперблока файловой системы
 *
 * Параметры:
 *        
 *        sb         -    указатель на экземпляр структуры данных ext2_super_block, в котором находится содержимое суперблока
 *                        файловой системы целевого логического раздела
 *
 *        devname    -    путь (относительный или абсолютный) и имя файла целевого логического раздела
 */
void print_superblock(const struct ext2_super_block *sb, const char *devname);

/* Функция read_object() считывает в специальный буфер содержимое объекта файловой системы
 *
 * Параметры:
 *
 *        dev_fd     -    номер файлового дескриптора открытого файла логического раздела
 *
 *        sb         -    указатель на описатель (экземпляр структуры данных ext2_super_block) суперблока файловой системы логического раздела
 *        
 *        inode      -    указатель на экземпляр структуры данных ext2_inode, в котором будет возвращено вызывающей подпрограмме
 *                        содержимое inode целевого объекта файловой системы
 *
 *        inum       -    номер inode целевого объекта файловой системы
 *
 *        cache      -    указатель на результирующий буфер
 *
 * Ограничения:
 *
 *        1. Размер объекта файловой системы не должен превышать 4144 килобайта (в файловых системах с размером блока == 4 килобайта),
 *           так как в функции read_object() не реализованы двойная и тройная косвенные адресации блоков
 *
 *        2. Размер cache должен быть равен, как минимум, 4144 килобайтам
 *
 * Возвращаемое значение:
 *
 *        0     -    в случае успеха:
 *            
 *                -    В объекте, на который указывает параметр inode, будет возвращено содержимое inode целевого объекта файловой системы
 *                -    В буфере cache будет возвращено содержимое объекта файловой системы
 *
 *        -1    -    в случае неудачи
 */
int read_object(int dev_fd, const struct ext2_super_block *sb, struct ext2_inode *inode, __le32 inum, void *cache);

/* Функция print_file() выводит в стандартный поток вывода содержимое целевого файла
 *
 * Параметры:
 *
 *        dev_fd     -    номер файлового дескриптора открытого файла логического раздела
 *
 *        sb         -    указатель на описатель (экземпляр структуры данных ext2_super_block) суперблока файловой системы логического раздела
 *        
 *        fname      -    абсолютный путь от корневого каталога файловой системы логического раздела и имя целевого файла
 *
 * Возвращаемое значение:
 *
 *        0     -    в случае успеха:
 *            
 *        -1    -    в случае неудачи
 */
int print_file(int dev_fd, const struct ext2_super_block *sb, const char *fname);

/* Главная подпрограмма */
int main(const int argc, const char *argv[])
{
    printf("\n");

    /* Если в программу передано количество аргументов, отличное от двух или трех, то пользователь ошибся с форматом запуска программы -
     * выведем справочную информацию и завершим программу */
    if(! (argc == 2 || argc == 3))
    {
        dprintf(2, "Форматы вызова:\n\n\
Вывод в стандартный поток вывода содержимого полей суперблока логического раздела:\n\n\
\t./program.out FS\n\n\
\t\tFS\t-\tпуть (относительный или абсолютный) и имя файла логического раздела,\n\
\t\t\t\tхранение данных на котором организуется с помощью одной из файловых систем: ext2 или ext3\n\n\
Вывод в стандартный поток вывода содержимого файла:\n\n\
\t./program.out FS FILE\n\n\
\t\tFS\t-\tпуть (относительный или абсолютный) и имя файла логического раздела,\n\
\t\t\t\tхранение данных на котором организуется с помощью одной из файловых систем: ext2 или ext3\n\
\t\tFILE\t-\tабсолютный путь от корня раздела FS и имя файла,\n\
\t\t\t\tсодержимое inode которого необходимо вывести в стандартный поток вывода\n\n");

        return -1;
    }

    /* Открываем файл логического раздела (путь (абсолютный или относительный) и имя данного файла переданы в программу в качестве
     * первого аргумента - argv[1] (argv[0] - имя исполняемого файла программы)) с режимом доступа только на чтение (O_RDONLY)
     *
     * Флаг O_LARGEFILE сообщает ОС, что открываемый файл, возможно, имеет размер больший, чем 2 гигабайта,
     * и манипуляции с открываемым файлом будут происходить с использованием 64-х разрядных знаковых смещений */
    int dev_fd = open(argv[1], O_RDONLY | O_LARGEFILE);

    if(dev_fd == -1)
    {
        dprintf(2, "Ошибка при открытии файла логического раздела: %s\n\n", strerror(errno));

        return -1;
    }

    /* Считываем суперблок файловой системы */
    struct ext2_super_block *sb = read_superblock(dev_fd);

    /* Если суперблок считать не удалось - закрываем файл логического раздела и завершаем программу с кодом ошибки -1 */
    if(sb == NULL)
    {
        close(dev_fd);

        return -1;
    }

    /* В зависимости от количества переданных в программу аргументов производим:
     *
     *        Передано 2 аргумента - вывод в стандартный поток вывода содержимого полей суперблока
     *
     *        Передано 3 аргумента - вывод в стандартный поток вывода содержимого целевого файла */
    if(argc == 2)
        print_superblock(sb, argv[1]);
    else
        print_file(dev_fd, sb, argv[2]);

    /* Закрываем файл логического раздела */
    close(dev_fd);

    /* Освобождаем память, выделенную системой под описатель суперблока */
    free(sb);

    printf("\n");

    return 0;
}

/* Функция read_superblock() возвращает указатель на экземпляр структуры данных ext2_super_block, содержащий описатель суперблока файловой системы,
 * номер файлового дескриптора открытого файла логического раздела которой передан параметром dev_fd */
struct ext2_super_block *read_superblock(int dev_fd)
{
    /* Предписываем ОС выделить память под описатель суперблока */
    struct ext2_super_block *ret = (struct ext2_super_block*) malloc(sizeof(struct ext2_super_block));

    if(ret == NULL)
        dprintf(2, "Ошибка при выделении динамической памяти с помощью функции malloc(): %s\n\n", strerror(errno));
    /* Если память под описатель суперблока успешно выделена, то считываем из файла логического раздела суперблок -
     * копия суперблока нулевой группы блоков расположена по смещению 1024 байта от начала логического раздела
     *
     * (в данном случае нет разницы, какой из системных вызовов использовать - pread (32-х разрядное знаковое смещение)
     * или pread64 (64-х разрядное знаковое смещение) - смещение в данном случае равно 1024, что укладывается в 2 гигабайта) */
    else if(
            pread64(dev_fd, ret, sizeof(struct ext2_super_block), 1024) != sizeof(struct ext2_super_block)
           )
    {
        /* При считывании суперблока произошла ошибка */
        dprintf(2, "Ошибка при считывании суперблока логического раздела: %s\n\n", strerror(errno));

        free(ret);

        ret = NULL;
    }

    /* Суперблок успешно считан */

    return ret;
}

/* Функция print_superblock() выводит в стандартный поток вывода содержимое полей суперблока файловой системы
 *
 * Параметры:
 *        
 *        sb             -    указатель на экземпляр структуры данных ext2_super_block, в котором находится содержимое суперблока
 *                            файловой системы целевого логического раздела
 *
 *        devname        -    путь (относительный или абсолютный) и имя файла целевого логического раздела
 */
void print_superblock(const struct ext2_super_block *sb, const char *devname)
{
    short x;
    const unsigned short kbsize = (EXT2_MIN_BLOCK_SIZE / 1024) << sb->s_log_block_size;
    const float gigabyte = 1024 * 1024;

    printf("Суперблок файловой системы типа ");

    if(sb->s_feature_compat & EXT3_FEATURE_COMPAT_HAS_JOURNAL)
        printf("ext3");
    else
        printf("ext2");

    printf(", созданной ОС");
    switch(sb->s_creator_os)
    {
        case EXT2_OS_LINUX:
            {
                printf(", использующей ядро Linux (например - GNU/Linux),");
                break;
            }
        case EXT2_OS_HURD:
            {
                printf(" Hurd (GNU/Hurd)");
                break;
            }
        case EXT2_OS_MASIX:
            {
                printf(" MASIX");
                break;
            }
        case EXT2_OS_FREEBSD:
            {
                printf(" FreeBSD");
                break;
            }
        case EXT2_OS_LITES:
            {
                printf(" Lites");
                break;
            }
    }

    printf(" и организованной на логическом разделе %s:\n\n", devname);

    printf("\tМагическая последовательность типа файловой системы:\t0x%X\t(EXT2_SUPER_MAGIC == EXT3_SUPER_MAGIC == 0x%X)\n\n", sb->s_magic, EXT2_SUPER_MAGIC);

    printf("\tРазмер блока:\t\t\t%u байт\n\n", EXT2_BLOCK_SIZE(sb));
    printf("\tКоличество блоков:\t\t%u\n", sb->s_blocks_count);
    printf("\tБлоков зарезервировано:\t\t%u\n", sb->s_r_blocks_count);
    printf("\tБлоков свободно:\t\t%u\n\n", sb->s_free_blocks_count);

    printf("\tРазмер файловой системы:\t%.3f гигабайт\n", sb->s_blocks_count * kbsize / gigabyte);
    printf("\tЗарезервировано:\t\t%.3f гигабайт\n", sb->s_r_blocks_count * kbsize / gigabyte);
    printf("\tСвободно:\t\t\t%.3f гигабайт\n\n", sb->s_free_blocks_count * kbsize / gigabyte);

    printf("\tРазмер inode:\t\t\t\t\t%u байт\n", EXT2_INODE_SIZE(sb));
    printf("\tКоличество inode:\t\t\t\t%u\n", sb->s_inodes_count);
    printf("\tInode свободно:\t\t\t\t\t%u\n", sb->s_free_inodes_count);
    printf("\tНомер первой не зарезервированной inode:\t%u\n\n", EXT2_FIRST_INO(sb));

    printf("\tБлоков в группе блоков:\t\t\t%u\n", EXT2_BLOCKS_PER_GROUP(sb));
    printf("\tInode в таблице inode группы блоков:\t%u\n", EXT2_INODES_PER_GROUP(sb));
    printf("\tГрупп блоков в файловой системе:\t%u\t\n", sb->s_blocks_count / EXT2_BLOCKS_PER_GROUP(sb) + 1);
    printf("\tРазмер группы блоков:\t\t\t%u мегабайт\n\n", sb->s_blocks_per_group * kbsize / 1024);

    printf("\tДата последнего монтирования файловой системы:\t\t%s", ctime((time_t *) & sb->s_mtime));
    printf("\tДата последней записи данных в файловую систему:\t%s", ctime((time_t *) & sb->s_wtime));
    printf("\tДата последней проверки файловой системы:\t\t%s\n", ctime((time_t *) & sb->s_lastcheck));
    
    printf("\tКоличество операций монтирования файловой системы, выполненных с момента ее последней проверки:\t\t\t%u\n", sb->s_mnt_count);
    printf("\tМаксимальное количество операций монтирования файловой системы, допустимых без выполнения ее проверки:\t\t");
    if(sb->s_max_mnt_count == 0xFFFF)
        printf("0xFFFF (соответствует бесконечности)\n");
    else
        printf("%u\n", sb->s_max_mnt_count);

    printf("\tИнтервал времени с момента последней проверки файловой системы до ее следующей принудительной проверки:\t\t%u%s\n\n",
            sb->s_checkinterval, sb->s_checkinterval ? "" : " (соответствует бесконечности)");
    
    printf("\tДействие ОС при обнаружении ошибки работы с файловой системой:\t");
    switch(sb->s_errors)
    {
        case EXT2_ERRORS_CONTINUE:
            {
                printf("проигнорировать ошибку и продолжить работу\n\n");
                break;
            }
        case EXT2_ERRORS_RO:
            {
                printf("перемонтировать файловую систему в режим \"только для чтения\"\n\n");
                break;
            }
        case EXT2_ERRORS_PANIC:
            {
                printf("породить критическую ошибку ядра (kernel panic)\n\n");
                break;
            }
    };

    printf("\tРевизия файловой системы: ");
    switch(sb->s_rev_level)
    {
        case EXT2_GOOD_OLD_REV:
            {
                printf("EXT2_GOOD_OLD_REV\n\n");
                break;
            }
        case EXT2_DYNAMIC_REV:
            {
                printf("EXT2_DYNAMIC_REV\n\n");

                printf("\t\tРасширения файловой системы:\n\n");
                printf("\t\t\tНекритичные (compat):\n\n");

                if(sb->s_feature_compat & EXT2_FEATURE_COMPAT_DIR_PREALLOC)
                    printf("\t\t\t\tEXT2_FEATURE_COMPAT_DIR_PREALLOC\t\t—\tрезервирование блоков файловой системы для только что созданных каталогов\n");
                if(sb->s_feature_compat & EXT3_FEATURE_COMPAT_HAS_JOURNAL)
                {
                    printf("\t\t\t\tEXT3_FEATURE_COMPAT_HAS_JOURNAL\t\t—\tрассматриваемая файловая система обладает журналом\n\t\t\t\t\t\t\t\t\t\t\
(номер inode файла журнала: %u)\n", sb->s_journal_inum);
                }
                if(sb->s_feature_compat & EXT2_FEATURE_COMPAT_EXT_ATTR)
                    printf("\t\t\t\tEXT2_FEATURE_COMPAT_EXT_ATTR\t\t—\tобъекты файловой системы обладают расширенными атрибутами\n");
                if(sb->s_feature_compat & EXT2_FEATURE_COMPAT_DIR_INDEX)
                    printf("\t\t\t\tEXT2_FEATURE_COMPAT_DIR_INDEX\t\t-\tиндексирование каталогов для ускорения поиска элементов каталога\n");

                printf("\n\t\t\tНекритичные, отсутствие поддержки которых ведет к монтированию файловой системы в режиме \"только для чтения\" (ro_compat):\
\n\n");
                if(sb->s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER)
                    printf("\t\t\t\tEXT2_FEATURE_RO_COMPAT_SPARSE_SUPER\t—\tкопии суперблока существуют не во всех группах блоков\n");
                if(sb->s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_LARGE_FILE)
                    printf("\t\t\t\tEXT2_FEATURE_RO_COMPAT_LARGE_FILE\t—\tподдержка файлов размером большим, чем 4-е гигабайта\n");
                if(sb->s_feature_ro_compat & EXT2_FEATURE_RO_COMPAT_BTREE_DIR)
                    printf("\t\t\t\tEXT2_FEATURE_RO_COMPAT_BTREE_DIR\t-\tвозможно использование B-деревьев для хранения результатов\n\
\t\t\t\t\t\t\t\t\t\tиндексирования содержимого отдельных каталогов\n");

                printf("\n\t\t\tКритичные, без поддержки которых монтирование файловой системы невозможно (incompat):\n\n");
                if(sb->s_feature_incompat & EXT2_FEATURE_INCOMPAT_COMPRESSION)
                    printf("\t\t\t\tEXT2_FEATURE_INCOMPAT_COMPRESSION\t—\tиспользуется сжатие объектов файловой системы\n");
                if(sb->s_feature_incompat & EXT3_FEATURE_INCOMPAT_RECOVER)
                    printf("\t\t\t\tEXT3_FEATURE_INCOMPAT_RECOVER\t\t—\tвосстановить файловую систему по журналу перед ее монтированием\n");
                if(sb->s_feature_incompat & EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)
                    printf("\t\t\t\tEXT3_FEATURE_INCOMPAT_JOURNAL_DEV\t—\tжурнал файловой системы типа ext3 хранится на внешнем устройстве\n\t\t\t\t\t\t\t\t\
\t\t(major == %u, minor = %u)", sb->s_journal_dev & 0xFFFF0000, sb->s_journal_dev & 0x0000FFFF);
                if(sb->s_feature_incompat & EXT2_FEATURE_INCOMPAT_META_BG)
                    printf("\t\t\t\tEXT2_FEATURE_INCOMPAT_META_BG\t\t—\tфайловая система хранит некоторые метаданные в специальных группах блоков\n\
\t\t\t\t\t\t\t\t\t\t(номер первой группы блоков, хранящей метаданные: %u)\n", sb->s_first_meta_bg);

                printf("\n\t\tИдентификатор логического раздела (UUID):\t0x");
                for(x = 0; x < 16; x++)
                    printf("%X", sb->s_uuid[x]);

                printf("\n\t\tМетка (имя) логического раздела:\t\t%s\n", sb->s_volume_name);

                break;
            }
    }
}

/* Функция read_object() считывает в специальный буфер содержимое объекта файловой системы
 *
 * Параметры:
 *
 *        dev_fd    -    номер файлового дескриптора открытого файла логического раздела
 *
 *        sb        -    указатель на описатель (экземпляр структуры данных ext2_super_block) суперблока файловой системы логического раздела
 *        
 *        inode     -    указатель на экземпляр структуры данных ext2_inode, в котором будет возвращено вызывающей подпрограмме
 *                       содержимое inode целевого объекта файловой системы
 *
 *        inum      -    номер inode целевого объекта файловой системы
 *
 *        cache     -    указатель на результирующий буфер
 *
 * Ограничения:
 *
 *        1. Размер объекта файловой системы не должен превышать 4144 килобайта (в файловых системах с размером блока == 4 килобайта),
 *           так как в функции read_object() не реализованы двойная и тройная косвенные адресации блоков
 *
 *        2. Размер cache должен быть равен, как минимум, 4144 килобайтам
 *
 * Возвращаемое значение:
 *
 *        0     -    в случае успеха:
 *            
 *                -    В объекте, на который указывает параметр inode, будет возвращено содержимое inode целевого объекта файловой системы
 *                -    В буфере cache будет возвращено содержимое объекта файловой системы
 *
 *        -1    -    в случае неудачи
 */
int read_object(int dev_fd, const struct ext2_super_block *sb, struct ext2_inode *inode, __le32 inum, void *cache)
{
    struct ext2_group_desc gd;

    /* Именованная константа bsize будет содержать размер в байтах блока файловой системы */
    const off64_t bsize = EXT2_BLOCK_SIZE(sb),
          /* Именованная константа s_gdsize будет содержать размер в байтах экземпляра структуры данных ext2_group_desc
           * Именованная константа s_isize будет содержать размер в байтах экземпляра структуры данных ext2_inode */
          s_gdsize = sizeof(struct ext2_group_desc), s_isize = sizeof(struct ext2_inode),
          /* Именованная константа dind_border будет содержать количество блоков файловой системы, которые могут быть адресованы
           * прямо или косвенно из inode объекта файловой системы
           *
           * (функция read_object не поддерживает двойную и тройную косвенные адресации; EXT2_NDIR_BLOCKS - количество блоков, адресуемых
           * прямо из inode, bsize / 4 - количество блоков, адресуемых косвенно) */
          dind_border = EXT2_NDIR_BLOCKS + bsize / 4;

    /* Считываем описатель группы блоков, в которой находится inode целевого объекта файловой системы
     *
     * Описатель группы блоков находится в массиве описателей групп блоков, который, в свою очередь, находится в нулевой
     * группе блоков по смещению bsize (то есть - непосредственно после копии суперблока, находящейся в нулевой группе блоков)
     *
     * inum - номер inode целевого объекта файловой системы. Inode нумеруются с единицы, поэтому необходимо вычесть (inum--)
     *        единицу из номера inode для удобства получения на основе номера inode различных смещений в различных массивах
     *
     * EXT2_INODES_PER_GROUP() - макрос, определяющий по описателю суперблока (указатель на который передается в данный макрос как параметр)
     *                           количество inode в группе блоков
     *
     * (inum-- / EXT2_INODES_PER_GROUP(sb)) - целочисленное деление номера inode (считая inode от нуля) на количество inode в группе блоков -
     *                                        то есть, фактически, номер блока (считая блоки от нуля), в котором расположена данная inode
     *
     * (s_gdsize * (inum-- / EXT2_INODES_PER_GROUP(sb))) - смещение описателя группы блоков с номером (inum-- / EXT2_INODES_PER_GROUP(sb)))
     *                                                     в массиве таковых описателей
     *
     * (bsize + (s_gdsize * (inum-- / EXT2_INODES_PER_GROUP(sb)))) - смещение от начала логического раздела описателя группы блоков, в которой
     *                                                               находится inode целевого объекта файловой системы */
    if(
        pread64(dev_fd, & gd, s_gdsize, bsize + s_gdsize * (inum-- / EXT2_INODES_PER_GROUP(sb))) < s_gdsize
      )
    {
        dprintf(2, "Ошибка при чтении описателя %u-й группы блоков файловой системы: %s\n", inum / EXT2_INODES_PER_GROUP(sb), strerror(errno));

        return -1;
    }

    /* Считываем inode целевого объекта файловой системы
     *
     * Inode целевого объекта файловой системы находится в массиве inode одной из групп блоков файловой системы. Описатель данной группы блоков
     * был считан предыдущим вызовом pread64() и находится в объекте gd
     *
     * gd.bg_inode_table - номер блока начала массива inode данной группы блоков
     *
     * (gd.bg_inode_table * bsize) - смещение от начала логического раздела блока начала массива inode данной группы блоков
     *
     * (inum % EXT2_INODES_PER_GROUP(sb)) - номер inode целевого объекта файловой системы в массиве inode данной (!) группы блоков -
     *                                      вычисляется как остаток от деления номера inode (считая inode от нуля) на количество inode в группе блоков
     *
     * EXT2_INODE_SIZE() - макрос, определяющий по суперблоку, указатель на описатель которого передается в данный макрос в качестве параметра,
     *                     размер в байтах inode в данной файловой системе
     *
     * ((inum % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb)) - смещение в байтах inode целевого объекта файловой системы от начала
     *                                                              массива inode группы блоков, в которой данная inode находится
     *
     * (gd.bg_inode_table * bsize + (inum % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb))) - смещение inode целевого объекта файловой системы
     *                                                                                           от начала логического раздела */
    if(
        pread64(dev_fd, inode, s_isize, gd.bg_inode_table * bsize + (inum % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb)) < s_isize
      )
    {
        dprintf(2, "Ошибка при чтении %u-й inode файловой системы: %s\n", inum, strerror(errno));

        return -1;
    }

    /* Поле i_blocks inode объекта файловой системы содержит количество блоков по 512 байт, данным объектом занимаемых -
     * чтобы получить количество блоков файловой системы, занимаемое данным объектом, поделим значение поля i_blocks на
     * количество блоков по 512 байт, содержащихся в одном блоке файловой системы */
    inode->i_blocks /= (bsize / 512);

    /* Если количество блоков, занимаемых целевым объектом файловой системы, превосходит dind_border -
     * то есть в inode используется двойная (а, возможно, и тройная) косвенная адресация -
     * завершаем выполнение функции с ошибкой, поскольку в данной функции не реализован функционал,
     * необходимый для работы с блоками, адресуемыми таковыми способами */
    if(inode->i_blocks >= dind_border)
    {
        dprintf(2, "Очередной объект файловой системы имеет размер, превышающий %llu килобайт => \
используется двойная косвенная адресация, не реализованная в данной программе\n", dind_border * bsize / 1024);

        return -1;
    }

    /* Считаем объект файловой системы в буфер cache */

    /* Переменная x - счетчик цикла - номер очередного считываемого блока целевого объекта файловой системы */
    int x;

    /* Переменная next будет адресовать очередной косвенно адресуемый блок и, соответственно,
     * будет использоваться при считывании в буфер cache косвенно адресуемых блоков */
    __le32 *next;
    
    /* Переменная temp будет адресовать очередную свободную область в буфере cache */
    void *temp = cache;

    for(x = 0; x < inode->i_blocks; x++)
    {
        /* Если очередной блок адресуется прямо из inode */
        if(x < EXT2_NDIR_BLOCKS)
        {
            /* Считаем данный блок
             *
             * (bsize * inode->i_block[x]) - смещение начала блока от начала логического раздела */
            if(
                pread64(dev_fd, temp, bsize, bsize * inode->i_block[x]) < bsize
              )
            {
                dprintf(2, "Ошибка при чтении %u-го блока файловой системы: %s\n", inode->i_block[x], strerror(errno));

                return -1;
            }

            /* Увеличиваем temp на размер только что считанного блока, тем самым переходя в буфере cache к очередной
             * свободной области */
            temp += bsize;
        }
        /* Если очередной блок адресуется косвенно */
        else
        {
            /* Если очередной блок - первый из адресуемых косвенно */
            if(x == EXT2_NDIR_BLOCKS)
            {
                /* Считываем блок косвенной адресации - то есть блок, содержащий номера косвенно адресуемых блоков */

                /* Переменная next будет указывать на номер очередного косвенно адресуемого блока. Номер очередного блока будет хранится в буфере,
                 * в который будет считан блок косвенной адресации - в качестве такового буфера мы будем использовать область
                 * размером в блок в конце буфера cache - в данную область, очевидно, может быть считан только самый последний
                 * косвенно адресуемый блок файловой системы, после считывания которого значение переменной next уже не понадобится,
                 * поскольку таковой блок, если он существует, гарантировано (предыдущими действиями функции) последний
                 * в считываемом объекте файловой системы */
                next = (__le32 *) (cache + (dind_border - 1) * bsize);

                /* Считываем блок косвенной адресации
                 *
                 * (bsize * inode->i_block[x]) - смещение начала блока от начала логического раздела */
                if(
                    pread64(dev_fd, (void *) next, bsize, bsize * inode->i_block[x]) < bsize
                  )
                {
                    dprintf(2, "Ошибка при чтении %u-го блока файловой системы: %s\n", inode->i_block[x], strerror(errno));

                    return -1;
                }
            }

            /* Считываем очередной косвенно адресуемый блок
             *
             * (* next) - разыменование указателя next, который указывает на номер косвенно адресуемого блока
             *
             * (bsize * (* next)) - смещение косвенно адресуемого блока от начала логического раздела */
            if(
                pread64(dev_fd, temp, bsize, bsize * (* next)) < bsize
              )
            {
                dprintf(2, "Ошибка при чтении %u-го блока файловой системы: %s\n", inode->i_block[x], strerror(errno));

                return -1;
            }
            
            /* Переходим на номер следующего косвенно адресуемого блока */
            next++;

            /* Увеличиваем temp на размер только что считанного блока, тем самым переходя в буфере cache к очередной
             * свободной области */
            temp += bsize;
        }
    }

    /* Считывание объекта файловой системы успешно завершено */

    return 0;
}

/* Функция print_file() выводит в стандартный поток вывода содержимое целевого файла
 *
 * Параметры:
 *
 *        dev_fd    -    номер файлового дескриптора открытого файла логического раздела
 *
 *        sb        -    указатель на описатель (экземпляр структуры данных ext2_super_block) суперблока файловой системы логического раздела
 *        
 *        fname     -    абсолютный путь от корневого каталога файловой системы логического раздела и имя целевого файла
 *
 * Возвращаемое значение:
 *
 *        0     -    в случае успеха:
 *            
 *        -1    -    в случае неудачи
 *
 * Общий алгоритм работы функции:
 *
 *        1. Создать буфер размером в ((EXT2_NDIR_BLOCKS + EXT2_BLOCK_SIZE(sb) / 4) * EXT2_BLOCK_SIZE(sb) + 1) байт
 *           - данный буфер будет использован для хранения содержимого объектов файловой системы
 *
 *           Здесь:
 *
 *                EXT2_NDIR_BLOCKS   -  константа компилятора, хранящая количество блоков, адресуемых напрямую из inode
 *
 *                EXT2_BLOCK_SIZE()  -  макрос, принимающий своим параметром указатель на экземпляр структуры данных ext2_super_block -
 *                                      описатель суперблока файловой системы - и возвращающий размер блока в байтах в данной файловой системе
 *
 *                1 байт             -  необходим для хранения нулевого символа, дописываемого к буферу в пункте 8.2, в случае,
 *                                      если файл имеет размер ровно ((EXT2_NDIR_BLOCKS + EXT2_BLOCK_SIZE(sb) / 4) * EXT2_BLOCK_SIZE(sb)) байт
 *        
 *        2. Разбить fname на подстроки. В качестве граничных символов подстрок считать символы '/' и '\0' 
 *        
 *        3. Рассматривать в качестве очередного каталога - корневой каталог
 *        
 *        4. Определить номер inode очередного каталога (для корневого каталога номер inode равен значению константы компилятора EXT2_ROOT_INO)
 *        
 *        5. Считать (с помощью функции read_object()) содержимое очередного каталога
 *
 *           5.1 Если каталог слишком большой (в его inode используется двойная косвенная адресация) - ошибка и останов
 *
 *        6. Считать очередную подстроку fname
 *
 *        7. Выполнить поиск объекта файловой системы с именем, совпадающим с очередной подстрокой fname
 *           
 *           7.1 Объект найден
 *
 *               7.1.1 Если объект - искомый файл, то переход на пункт 8
 *
 *               7.1.2 Если объект - искомый, но файлом не является, то ошибка и останов
 *
 *               7.1.3 Если объект - каталог и искомым (последним в fname) не является, то переход на пункт 4
 *
 *           7.2 Объект не найден - ошибка и останов
 *
 *        8. Файл найден - считать (с помощью функции read_object()) содержимое файла
 *
 *           8.1 Если файл слишком большой (в его inode используется двойная косвенная адресация) - ошибка и останов
 *
 *           8.2 Если в inode файла не используется двойная косвенная адресация, то в конец буфера дописать нулевой символ ('\0')
 *               и выполнить вывод содержимого буфера в стандартный поток вывода
 *
 *        9. Освободить память, отведенную под буфер
 */
int print_file(int dev_fd, const struct ext2_super_block *sb, const char *fname)
{
    /* Абсолютный путь и имя файла копируем в строку tfname, которая будет использоваться нами для выделения подстрок */
    char *tfname = strdup(fname);

    /* Именованная константа bsize будет содержать размер в байтах блока файловой системы */
    const off64_t bsize = EXT2_BLOCK_SIZE(sb);

    /* Именованная константа csize будет содержать размер буфера, в который будут считываться обрабатываемые объекты файловой системы
     * (в каждый момент времени в данном буфере будет находится только один - обрабатываемый в данный момент - объект файловой системы)
     *
     * EXT2_NDIR_BLOCKS - количество блоков, адресуемых напрямую из inode
     * 
     * bsize / 4 - количество блоков, адресуемых косвенно
     *
     * (EXT2_NDIR_BLOCKS + bsize / 4) - максимальное количество блоков, считывание которых возможно - максимальное количество блоков,
     *                                  адресуемых прямо или косвенно (двойная и тройная косвенные адресации нами не поддерживаются)
     *
     * (+ 1) - дополнительный байт, в который будет записан символ '\0' в процессе подготовки к выводу содержимого файла в стандартный поток вывода
     *         в случае, если размер искомого файла в точности равен (EXT2_NDIR_BLOCKS + bsize / 4) блокам */
    const off64_t csize = (EXT2_NDIR_BLOCKS + bsize / 4) * bsize + 1;

    /* Указатель cache будет содержать адрес буфера */
    void *cache;

    if(tfname == NULL)
    {
        perror("Ошибка при выделении динамической памяти с помощью функции strdup()");

        return -1;
    }
    /* Создаем буфер в виде неразделяемого (MAP_PRIVATE) анонимного (MAP_ANONYMOUS) отображения, доступного для чтения (PROT_READ) и записи (PROT_WRITE) */
    else if(
            (cache = mmap(NULL, csize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) == MAP_FAILED
           )
    {
        perror("Ошибка при создании анонимного отображения");

        free(tfname);

        return -1;
    }

    /* Объект inode будет содержать inode очередного каталога из абсолютного пути к целевому файлу или inode самого файла */
    struct ext2_inode inode;

    /* Объекты dentry и next_dentry будут содержать dentry (directory entry; описатель элемента каталога) элементов каталога
     *
     * (мы используем структуру данных ext2_dir_entry_2, исходя из предположения, что подавляющее большинство файловых систем ext2 / ext3
     * на данный момент используют именно ее, а не устаревшую ext2_dir_entry) */
    struct ext2_dir_entry_2 *dentry, *next_dentry;

    /* Первым каталогом, который будет считан нами, станет корневой каталог с номером inode равным значению константы компилятора EXT2_ROOT_INO */
    dentry = (struct ext2_dir_entry_2 *) cache;
    dentry->inode = EXT2_ROOT_INO;

    int x, not_found = 0;
    size_t obj_len;

    /* Инициализируем обход подстрок строки tfname с символами '/' и '\0' в качестве разделителей подстроки -
     * будем последовательно вычленять имена каталогов и имя целевого файла из строки tfname,
     * содержащей абсолютный путь от корневого каталога логического раздела и имя целевого файла */
    char *obj = strtok(tfname, "/");

    if(obj == NULL)
    {
        dprintf(2, "Невозможно считать корневой каталог\n");

        free(tfname);
        munmap(cache, csize);

        return -1;
    }

    /* Пока очередной каталог существует (! not_found или (dentry->inode == EXT2_ROOT_INO) - то есть, поиск только начался)
     * и поиск не закончен (функция strtok() не вернула NULL - то есть не закончила обход подстрок строки tfname) повторять */
    while(
            ! not_found
            &&
            (
                dentry->inode == EXT2_ROOT_INO
                ||
                (obj = strtok(NULL, "/")) != NULL
            )
         )
    {
        /* Считываем в буфер cache содержимое очередного каталога, inode которого имеет номер равный dentry->inode
         * Inode очередного каталога будет считано в объект inode */
        if(
            read_object(dev_fd, sb, & inode, dentry->inode, cache) == -1
          )
        {
            free(tfname);
            munmap(cache, csize);

            return -1;
        }

        /* Обходим содержимое каталога в поисках каталога с именем obj (указатель obj содержит адрес подстроки строки tfname) */

        obj_len = strlen(obj);
        not_found = 1;

        /* dentry - указывает на предыдущую dentry (данный указатель необходим в силу того, что нижеследующий цикл for перед своим завершением
         * из-за найденного элемента каталога изменит значение адреса текущей анализируемой dentry, переведя его на следующую за найденной) */
        dentry = next_dentry;
        /* next_dentry - указывает на текущую анализируемую dentry */
        next_dentry = cache;

        for(
                ;
                /* До тех пор, пока не достигнут конец каталога (элемент типа EXT2_FT_UNKNOWN) и
                 * искомый элемент каталога  не найден (not_found) повторять */
                next_dentry->file_type != EXT2_FT_UNKNOWN && not_found;
                /* Действия, выполняемые после каждой итерации перед проверкой условий продолжения цикла:
                 * 
                 * (dentry = next_dentry) - сохранить в dentry адрес только что обработанного dentry (если not_found == 0,
                 *                          то именно dentry будет указывать на искомый элемент каталога)
                 *
                 * (next_dentry = (struct ext2_dir_entry_2 *) ((void *) next_dentry + next_dentry->rec_len)
                 *        - перейти на очередной элемент каталога (поле next_dentry->rec_len содержит размер записи о только что обработанном элементе -
                 *          то есть содержит количество байт, на которое необходимо изменить значение указателя next_dentry) */
                dentry = next_dentry, next_dentry = (struct ext2_dir_entry_2 *) ((void *) next_dentry + next_dentry->rec_len)
           )
            /* Если размер в байтах имени очередного элемента каталога (поле name_len dentry) совпадает с размером в байтах имени искомого элемента каталога */
            if(! (not_found = ! (next_dentry->name_len == obj_len)))
                /* До тех пор, пока в имени элемента каталога присутствуют необработанные символы и не найдена пара не совпадающих символов, повторять */
                for(x = 0; x < next_dentry->name_len && ! not_found; x++)
                    /* Если очередные символы имен не совпадают - флаг "не найденности" элемента каталога (not_found) устанавливается в 1 */
                    if(next_dentry->name[x] != obj[x])
                        not_found = 1;
    }

    /* Освобождаем память, выделенную системой под строку tfname */
    free(tfname);

    /* Если файл или один из каталогов из абсолютного пути к файлу не найден - выводим сообщение об ошибке */
    if(not_found)
    {
        dprintf(2, "Файл %s не найден", fname);

        if(obj != NULL)
            dprintf(2, " - объект %s файловой системы не найден\n", obj);

        munmap(cache, csize);

        return -1;
    }
    /* Если найденный объект файловой системы не является обычным (регулярным) файлом - выводим сообщение об ошибке */
    else if(
            dentry->file_type != EXT2_FT_REG_FILE
           )
    {
        dprintf(2, "Объект %s файловой системы не является обычным (регулярным) файлом\n", fname);

        munmap(cache, csize);

        return -1;
    }
    /* Если искомый файл найден, то считываем его содержимое */
    else if(
            read_object(dev_fd, sb, & inode, dentry->inode, cache) == -1
           )
    {
        munmap(cache, csize);

        return -1;
    }
    else
    {
        /* Содержимое искомого файла успешно считано */

        /* В конец файла помещаем нулевой символ (поле i_size inode файла содержит размер файла в байтах) */
        ((char *) cache)[inode.i_size] = '\0';

        /* Выводим содержимое файла */
        printf("############################################################################\n\nСодержимое файла %s:\n\n%s\n\n\
############################################################################\n", fname, (char *) cache);
    }

    /* Удаляем анонимное отображение, выделенное под буфер */
    munmap(cache, csize);

    return 0;
}

