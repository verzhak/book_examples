
#define _GNU_SOURCE		/* Для mkostemp() */

#include <stdio.h>
#include <stdlib.h>

#include <signal.h>		/* Для kill() */
#include <wait.h>		/* Для wait() */
#include <unistd.h>		/* Для fork() */
#include <sys/types.h>
#include <sys/file.h>	/* Для flock() */

int main()
{
	char path[] = "./tempXXXXXX";

	/* Создать временный файл и открыть его на запись
	 *
	 * (файловый дескриптор parent_fd будет использовать родительский процесс) */
	int parent_fd = mkostemp(path, O_WRONLY);

	if(parent_fd == -1)
	{
		perror("Ошибка при создании временного файла");
		return -1;
	}

	/* Открыть временный файл на чтение
	 *
	 * (файловый дескриптор child_fd будет использовать дочерний процесс) */
	int child_fd = open(path, O_RDONLY);

	if(child_fd == -1)
	{
		perror("Ошибка при открытии на чтение временного файла");

		close(parent_fd);
		return -1;
	}

	/* Родительский процесс устанавливает эксклюзивную блокировку на файл */
	if(
			flock(parent_fd, LOCK_EX) == -1
	  )
	{
		perror("Установка эксклюзивной блокировки завершилась неудачей");

		close(parent_fd);
		close(child_fd);
		return -1;
	}

#define BUF_SIZE 555
	char buf[BUF_SIZE];

	/* Запустить дочерний процесс */
	int child = fork();

	if(child == -1)
	{
		perror("Ошибка при запуске дочернего процесса");

		close(parent_fd);
		close(child_fd);
		return -1;
	}
	else if(child)
	{
		/* Мы в родительском процессе */

		/* Родительский процесс не должен использовать файловый дескриптор, предназначенный
		 * для использования в дочернем процессе - родительский процесс закрывает данный файловый дескриптор */
		close(child_fd);

		/* Генерация произвольного наполнения буфера (массив buf) */
		short x;
		for(x = 0; x < BUF_SIZE - 1; x++)
		{
			if((x + 1) % 65)
				buf[x] = rand() % 26 + 'A';
			else
				buf[x] = '\n';
		}

		/* Буфер - строка => должен завершаться нулевым символом */
		buf[BUF_SIZE - 1] = '\0';

		/* Родительский процесс сбрасывает в файл содержимое буфера */
		if(
				write(parent_fd, buf, BUF_SIZE) == -1
		  )
		{
			perror("Ошибка при записи в файл");

			close(parent_fd);
			kill(child, SIGKILL);
			return -1;
		}

		/* Родительский процесс снимает эксклюзивную блокировку с файла =>
		 * дочерний процесс сможет прочитать данные из файла */
		if(
				flock(parent_fd, LOCK_UN) == -1
		  )
		{
			perror("Ошибка при снятии блокировки");

			close(parent_fd);
			kill(child, SIGKILL);
			return -1;
		}

		/* Родительский процесс закрывает свой дескриптор временного файла */
		close(parent_fd);

		/* Родительский процесс ожидает произвольных событий от любого дочернего процесса -
		 * в данном случае существует лишь один дочерний процесс и единственное, что с ним может случиться -
		 * завершение */
		wait(NULL);

		/* Родительский процесс удаляет временный файл (точнее, удаляет жесткую ссылку на файл из некоторого каталога
		 * (имя ссылки и путь к каталогу указаны в параметре path) - если счетчик ссылок на файл станет равным
		 * нулю (а он станет), то файл будет удален) */
		unlink(path);
	}
	else
	{
		/* Мы в дочернем процессе */

		/* Дочерний процесс закрывает родительский дескриптор временного файла */
		close(parent_fd);

		/* Дочерний процесс пытается установить эксклюзивную блокировку на файл -
		 * процесс будет блокирован до тех пор, пока родительским процессом не будет
		 * снята конкурирующая блокировка */
		if(
				flock(child_fd, LOCK_EX) == -1
		  )
		{
			perror("Установка эксклюзивной блокировки завершилась неудачей");

			close(child_fd);
			return -1;
		}

		/* Родительский процесс снял блокировку => в файле появились данные, записанные в него родительским
		 * процессом. Дочерний процесс читает данные в буфер */
		if(
				read(child_fd, buf, BUF_SIZE) == -1
		  )
			perror("Ошибка при чтении данных из файла");
		else
		{
			printf("\n----------------------> Начало сообщения <----------------------\n");
			printf("%s\n----------------------> Конец  сообщения <----------------------\n\n", buf);
		}

		/* Дочерний процесс закрывает принадлежащий ему дескриптор временного файла */
		close(child_fd);
	}

	return 0;
}

