
/* ############################################################################
 *
 * Применение частотного анализа для дешифрования шифротекстов, полученных с
 * помощью шифра Цезаря
 *
 * Шифр Цезаря:
 *		
 *		Замена каждого символа символом того же алфавита,
 *		начало которого циклически сдвинуто вправо на несколько позиций
 *
 *		Пример:
 *			алфавит A B C D ... X Y Z
 *			замены	D E F G ... A B C
 *
 *			Таким образом, CYD -> FBG и так далее
 *
 *	Частотный способ:
 *		
 *		Известно, что в английском языке чаще всего встречается буква E. Таким
 *		образом, та буква шифротекста, что встречается в нем чаще всего, с большой
 *		вероятностью и будет буквой E в открытом тексте. На основе данной идеи можно
 *		получить шаг сдвига и восстановить открытый текст
 *
 *	Родительский и дочерний процессы:
 *
 *		1)	Родительский процесс отправляет дочернему некоторое количество
 *			независимых	шифротекстов (в сообщения типа CRYPT);
 *		2)	Дочерний процесс дешифрует шифротексты и отправляет	соответствующие
 *			открытые тексты родительскому процессу (в сообщениях типа DECRYPT);
 *		3)	Когда у родительского процесса заканчиваются шифротексты, он 
 *			отправляет дочернему сообщение типа END, после чего оба процесса
 *			завершаются.
 *
 * ############################################################################ */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>		/* Для fork() */
#include <signal.h>		/* Для kill() */
#include <sys/wait.h>	/* Для wait() */
#include <sys/types.h>	/* Для msgget(), msgctl(), msgsnd(), msgrcv() */
#include <sys/ipc.h>
#include <sys/msg.h>

/* Ключ доступа к очереди */
#define KEY		7777

/* Структура данных, описывающая сообщения */
struct message
{
	/* Типы сообщений
	 * (их значения больше нуля и имеют тип long) */
	#define END		1L
	#define CRYPT	2L
	#define DECRYPT 3L

	long mtype;

	/* Буфер для передачи текстов */
	char buf[100];
};

/* Непосредственное дешифрование частотным способом шифротекста, переданного
 * параметром ct */
void decrypt(char *ct)
{
	int x, b;
	unsigned int alp[26];

	/* Предполагается, что в конце шифротекста в ct есть нулевой символ ('\0') */
	size_t len = strlen(ct);

	memset((void *) alp, 0, sizeof(int) * 26);

	b = 0;

	/* Нахождение частот появления в шифротексте символов латинского алфавита */
	for(x = 0; x < len; x++)
	{
		ct[x] -= 'A';

		if(++alp[ct[x]] > alp[b])
			b = ct[x];
	}

	/* b - номер, считая с нуля, буквы латинского алфавита, которой
	 * соответствует буква E в открытом тексте */
	b -= ('E' - 'A');

	if(b < 0)
		b += 26;

	/* Получение букв открытого текста сдвигом влево по алфавиту с шагом b */
	for(x = 0; x < len; x++)
	{
		if((ct[x] -= b) < 0)
			ct[x] += 26;

		ct[x] += 'A';
	}
}

/* Главная функция дочернего процесса */
void child_main()
{
	/* Получение идентификатора очереди сообщений по ее ключу */
	int id = msgget(KEY, 0600 | IPC_CREAT);

	if(id == -1)
		/* Ошибка при получении дескриптора очереди сообщений */
		exit(-1);

	char flag = 1;

	struct message msg;

	/* Пока родительский процесс не прислал сообщение типа END */
	while(flag)
	{
		/* Выбирать из очереди очередное сообщение с типом, значение которого меньше
		 * или равно CRYPT (типы END и CRYPT) */
		if(
				msgrcv(id, (void *) & msg, sizeof(struct message) - sizeof(long), - CRYPT, 0) != -1
				&&
				msg.mtype == CRYPT
		  )
		{
			/* Пришло сообщение типа CRYPT */

			/* Дешифровать полученный шифротекст */
			decrypt(msg.buf);

			msg.mtype = DECRYPT;

			/* Отправление родительскому процессу сообщения с типом DECRYPT и открытым текстом
			 * внутри сообщения */
			if(
					msgsnd(id, (void *) & msg, sizeof(msg) - sizeof(long), 0) == -1
			  )
			{
				/* Ошибка при отправлении сообщения */

				kill(getppid(), SIGTERM);
				exit(-1);
			}
		}
		else
			/* Ошибка (msgrcv() вернула -1) или команда окончания работы (mtype == END) */
			flag = 0;
	}

	exit(0);
}

int main()
{
	/* Создание дочернего процесса */
	int x, child = fork();

	if(child == -1)
	{
		perror("Ошибка при запуске дочернего процесса");
		return -1;
	}
	else if(! child)
		/* Мы в дочернем процессе */
		child_main();

	/* Мы в родительском процессе */

	/* Создание новой очереди сообщений с данным ключом */
	int id = msgget(KEY, 0600 | IPC_CREAT);

	if(id == -1)
	{
		perror("Ошибка при создании очереди");

		kill(child, SIGKILL);
		return -1;
	}

	struct message msg[2];

	/* Два шифротекста */
	strcpy(msg[0].buf, "FQOCUDEMUUUU");
	strcpy(msg[1].buf, "PXPXKXENVDRUXVTNLXHYMXGMAXYKXJNXGVRFXMAHWGXXWLEHGZXKVBIAXKMXQM");

	for(x = 0; x < 2; x++)
	{
		msg[x].mtype = CRYPT;

		printf("\nШифротекст: [%s]\n", msg[x].buf);

		/* Отправление дочернему процессу сообщения с типом CRYPT и шифротекстом в теле
		 * сообщения */
		if(
				msgsnd(id, (void *) & msg[x], sizeof(struct message) - sizeof(long), 0) == -1
		  )
			perror("Ошибка при отправлении шифротекста");

		/* Получение от дочернего процесса сообщения с типом DECRYPT и открытым текстом в теле
		 * сообщения */
		if(
				msgrcv(id, (void *) & msg[x], sizeof(struct message) - sizeof(long), DECRYPT, 0) == -1
		  )
			perror("Ошибка при принятии открытого текста");

		printf("Открытый текст: [%s]\n", msg[x].buf);
	}

	printf("\n");

	struct message end_msg = { .mtype = END };

	/* Отправление дочернему процессу сообщения типа END - предписание завершить свое выполнение */
	if(
			msgsnd(id, (void *) & end_msg, sizeof(struct message) - sizeof(long), 0) == -1
	  )
			perror("Ошибка при отправлении команды завершения");

	if(
			msgctl(id, IPC_RMID, NULL) == -1
	  )
		perror("Ошибка при удалении очереди сообщений");

	/* Ожидание завершения дочернего процесса */
	do
		wait(& x);
	while(! WIFEXITED(x));

	return 0;
}

