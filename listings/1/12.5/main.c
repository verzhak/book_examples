
/* Получение для переданных в программу целых чисел из диапазона [3; 255] значений функции Эйлера, наименьших первообразных корней
 * и построение для переданных в программу целых чисел и их наименьших первообразных корней таблиц "индекс -> число"
 *
 * Теоретическая часть:
 *
 *		Исходное целое число - m
 *
 *		Функция Эйлера - количество таких целых неотрицательных phi, что phi < m, phi и m взаимно простые
 *
 *		Первообразный корень - такое целое неотрицательное y, что (y ^ phi) mod m = 1
 *
 *		Таблица "индекс -> число" - двухмерная таблица:
 *
 *						      |   0 |   1 |   2 |   3 |   4 |   5 |   6 |   7 |   8 |   9 |		<--- единицы
 *					 ----------------------------------------------------------------------
 *					        0 |  z0 |  z1 |                     ...                 |  z9 |
 *					 ----------------------------------------------------------------------
 *					        1 | z10 | z11 |                     ...                 | z19 |
 *					 ----------------------------------------------------------------------
 *	 				      ... |                                 ...                       |
 *					 ----------------------------------------------------------------------
 *					 m div 10 | zM0 | zM1 |    ...    | m - m div 10 |--------------------|
 *					 ----------------------------------------------------------------------
 *					  ^                                      ^
 *					  |                                      |
 *					  |                                      |
 *					  десятки                              z(M-1)
 *
 *					  По вертикали и горизонтали - индексы (iX), в ячейках - числа (zX) таковые, что:
 *
 *							(y ^ iX) mod m = zX
 *
 *					  Операция индексирования:
 *
 *							(ind zX по основанию y) mod m = iX
 *
 * Задача:
 *
 *		1. Вычислить для исходного числа функцию Эйлера
 *		2. Найти для исходного числа наименьший первообразный корень
 *		3. Построить для наименьшего первообразного корня исходного числа таблицу "индекс -> число"
 */

#define _GNU_SOURCE		/* Для dprintf() */

#include <stdio.h>
#include <stdlib.h>

#include <stdint.h>		/* Для uint8_t, uint16_t, int16_t, uint32_t */
#include <sys/mman.h>	/* Для mmap() и munmap() */
#include <pthread.h>	/* Для pthread_attr_init(), pthread_attr_setstack(), pthread_create(), pthread_attr_destroy(), pthread_join и pthread_exit() */

/* Функция eval() - главная функция дочерних потоков - для заданного числа вычисляет функцию Эйлера, ищет наименьший первообразный корень,
 * строит таблицу "индекс -> число" для заданного числа и его наименьшего первообразного корня
 *
 * Параметр:
 *
 *		Указатель pm - последний байт его значения суть есть заданное число
 *
 * Возвращаемое значение:
 *
 *		NULL - в случае неудачи
 *
 *		Указатель на массив однобайтовых неотрицательных целых чисел в случае успешного завершения потока. В данном массиве:
 *
 *			0-й элемент - заданное число
 *
 *			1-й элемент - значение функции Эйлера для заданного числа
 *
 *			2-й элемент - наименьший первообразный корень для заданного числа
 *
 *			3 - (заданное число + 3) элементы - числа для индексов от 0 до (заданное число - 1) - то есть таблица "индекс -> число"
 *			    для заданного числа и его наименьшего первообразного корня
 */
void *eval(void *pm);

/* Размер стеков дочерних потоков (минимально допустимое значение (по крайней мере, в openSUSE 11.1) - 16 килобайт) */
#define STACK_SIZE 16384

/* Указатель на массив указателей на стеки дочерних потоков */
void **stack;

/* Главная функция программы */
int main(const int argc, const char *argv[])
{
	/* Если пользователь не передал программе чисел для обработки - выведем в стандартный поток вывода информацию о формате запуска программы 
	 * и завершим выполнение программы с кодом завершения -1 */
	if(argc < 2)
	{
		dprintf(2, "\n\
Формат вызова программы:\n\n\
./program.out NUM_1 [ NUM_2 [ ... [ NUM_N ] ] ]\n\n\
\tNUM_1 NUM_2... NUM_N\t-\tцелые числа из диапазона [3; 255] (дробные числа округляются в меньшую сторону),\n\
\t\t\t\t\tдля каждого из которых программа находит значение функции Эйлера, минимальный первообразный корень\n\
\t\t\t\t\tи строит для данного корня таблицу \"индекс -> число\"\n\n");

		return -1;
	}

	/* Выделяем память под массив указателей на стеки дочерних потоков - аргументов в программу передано (argc - 1) =>
	 * чисел для обработки будет не больше, чем (argc - 1) штук => необходимо (argc - 1) потоков => необходимо (argc - 1) указателей на стеки */
	if(
		(stack = (void **) malloc(sizeof(void*) * (argc - 1))) == NULL
	  )
	{
		perror("\nОшибка при выделении памяти под массив указателей на стеки дочерних потоков");

		return -1;
	}

	int16_t x, y, z;

	/* Создаем стеки потоков как анонимные (MAP_ANONYMOUS) неразделяемые (MAP_PRIVATE) отображения, доступные для чтения (PROT_READ),
	 * записи (PROT_WRITE) и исполнения (PROT_EXEC) */
	for(y = 1; y < argc; y++)
		if(
			(stack[y - 1] = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) == MAP_FAILED
		  )
		{
			perror("\nОшибка при выделении памяти под стек одного из дочерних потоков");

			/* Если создание одного из стеков завершилось неудачей - уничтожим уже созданные стеки, уничтожим массив указателей на стеки и
			 * завершим выполнение программы с кодом завершения -1 */

			for(y--; y >= 0; y--)
				munmap(stack[y], STACK_SIZE);

			free(stack);

			return -1;
		}

	/* Массив is_run будет хранить флаги, каждый из которых будет установлен в единицу, если соответствующий ему поток запущен,
	 * и в ноль, если соответствующий ему поток запустить не удалось */
	uint8_t is_run[argc - 1];

	/* Массив thread будет хранить описатели потоков */
	pthread_t thread[argc - 1];

	/* Переменная attr суть есть описатель атрибутов запускаемых дочерних потоков */
	pthread_attr_t attr;

	long long tx;

	/* Для каждого аргумента, переданного в программу, повторять */
	for(y = 0; y < (argc - 1); y++)
	{
		/* Из очередного аргумента, переданного в программу, получаем число:
		 *
		 *		Если в начале аргумента есть целое число, оно будет записано в tx
		 *
		 *		Если в начале аргумента есть дробное число, оно будет округлено вниз и результат округления будет записан в tx
		 *
		 *		Если в начале аргумента нет числа, то в tx будет записано некоторое неопределенное значение (скорее всего 0) */
		tx = atoll(argv[y + 1]);

		/* Проверяем, попадает ли обрабатываемое число в допустимый диапазон [3; 255] */
		if(tx < 3 || tx > 255)
		{
			dprintf(2, "\nАргумент %s не является числом или выходит за рамки диапазона [3; 255]\n", argv[y + 1]);

			is_run[y] = 0;
		}
		/* Если обрабатываемое число попадает в допустимый диапазон */
		else if(
				/* Инициализируем описатель атрибутов запускаемого потока */
				pthread_attr_init(& attr)
				||
				/* Устанавливаем адрес (stack[y]) и размер (STACK_SIZE) стека запускаемого потока */
				pthread_attr_setstack(& attr, stack[y], STACK_SIZE)
				||
				/* Запускаем дочерний поток, передавая в него в качестве младшего байта параметра главной функции потока обрабатываемое число */
				pthread_create(& thread[y], & attr, & eval, (void *) tx)
			  )
		{
			dprintf(2, "\nОшибка при запуске %d-го дочернего потока\n", y);

			is_run[y] = 0;
		}
		/* Очередной дочерний поток успешно запущен - устанавливаем значение соответствующего флага в единицу */
		else
			is_run[y] = 1;
	}

	/* Все дочерние потоки запущены - уничтожаем описатель атрибутов запускаемых потоков */
	pthread_attr_destroy(& attr);

	/* Указатель table будет содержать адрес массива, в котором будут сохранены дочерним потоком результаты его выполнения */
	uint8_t *table;

	/* Для каждого переданного в программу аргумента повторять */
	for(y = 0; y < (argc - 1); y++)
	{
		/* Если поток, обрабатывающий очередной аргумент, запущен */
		if(is_run[y])
		{
			/* Ожидаем завершение запущенного потока */
			if(
				pthread_join(thread[y], (void **) & table)
				||
				table == NULL
			  )
				dprintf(2, "\nПоток %d завершился неудачей\n", y);
			/* Если поток завершился успешно (то есть вернул не нулевой указатель на массив, содержащий результаты выполнения данного потока),
			 * то выведем в стандартный поток вывода обработанное завершившимся потоком число, значение функции Эйлера для данного числа,
			 * значение наименьшего первообразного корня для данного числа, а также содержимое таблицы "индекс -> число" для данного числа
			 * и соответствующего ему наименьшего первообразного корня */
			else
			{
				#define B_LINE printf("\n#################################################################\n\n");
				#define P_LINE printf("\n-----------------------------------------------------------------\n");

				B_LINE;

				printf("Модуль: %u\n\n", table[0]);
				printf("Функция Эйлера: %u\n\n", table[1]);
				printf("Наименьший первообразный корень: %u\n\n", table[2]);

				printf("                      Таблица индекс -> число\n");

				P_LINE;

				printf("    |");

				for(x = 0; x < 10; x++)
					printf("  %d  |", x);

				for(x = 0; x < table[0]; x++)
				{
					if(! (x % 10))
					{
						P_LINE;

						printf(" %2d |", x / 10);
					}

					printf(" %3d |", table[x + 3]);
				}

				for(x = table[0] % 10; x % 10; x++)
					printf("     |");

				P_LINE;

				B_LINE;

				/* После вывода результатов выполнения очередного потока вернем ОС память, выделенную данному потоку под его результирующий массив */
				free(table);
			}
		}

		/* Уничтожаем анонимное отображение, на основе которого был организован стек потока, отвечающего за обработку очередного аргумента программы
		 *
		 * (даже если таковой поток запущен не был, стек его все равно был нами создан) */
		munmap(stack[y], STACK_SIZE);
	}

	/* Возвращаем ОС память, отведенную под массив указателей на стеки дочерних потоков */
	free(stack);

	printf("\n");

	return 0;
}

/* Функция eval() - главная функция дочерних потоков - для заданного числа вычисляет функцию Эйлера, ищет наименьший первообразный корень,
 * строит таблицу "индекс -> число" для заданного числа и его наименьшего первообразного корня
 *
 * Параметр:
 *
 *		Указатель pm - последний байт его значения суть есть заданное число
 *
 * Возвращаемое значение:
 *
 *		NULL - в случае неудачи
 *
 *		Указатель на массив однобайтовых неотрицательных целых чисел в случае успешного завершения потока. В данном массиве:
 *
 *			0-й элемент - заданное число
 *
 *			1-й элемент - значение функции Эйлера для заданного числа
 *
 *			2-й элемент - наименьший первообразный корень для заданного числа
 *
 *			3 - (заданное число + 3) элементы - числа для индексов от 0 до (заданное число - 1) - то есть таблица "индекс -> число"
 *			    для заданного числа и его наименьшего первообразного корня
 */
void *eval(void *pm)
{
	/* Получаем значение младшего байта единственного параметра главной функции дочернего потока - данный байт содержит обрабатываемое число */
	uint8_t m = (uint8_t) pm;

	/* Предписываем ОС выделить область виртуального адресного пространства процесса под результирующий массив дочернего потока */
	uint8_t *table = (uint8_t *) malloc(m + 3);

	/* Если область виртуального адресного пространства процесса успешно выделена */
	if(table != NULL)
	{
		table[0] = m;

		/* Массив sdiv содержит все простые числа из диапазона [2, 255] и следующее за 255-ю простое число (257) -
		 * всего nsdiv (55) простых чисел */
		const uint8_t nsdiv = 55;
		const uint16_t sdiv[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
								 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,
								 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257 };

		/* Массив m_sdiv будет содержать все простые множители обрабатываемого числа, входящие в данный массив количество раз,
		 * совпадающее со степенью, с которой данный простой множитель входит в разложение обрабатываемого числа
		 *
		 * Размер массива m_sdiv будет сохранен в переменной m_nsdiv. Очевидно, что максимальный размер массива m_sdiv равен 7 (2 ^ 8 = 256 > 255) */
		uint8_t m_nsdiv = 0, m_sdiv[7], x, y, u = 0;

		/* Раскладываем обрабатываемое число на простые множители */
		for(x = 0; sdiv[x] <= m; x++)
			if(! (m % sdiv[x]))
			{
				m_sdiv[m_nsdiv] = sdiv[x];

				m_nsdiv++;

				m /= sdiv[x];

				x = 0;
			}

		/* Вычисляем функцию Эйлера */
		table[1] = table[0] - 1;
		for(x = 2; x < table[0]; x++)
			for(y = 0; y < m_nsdiv; y++)
				if(! (x % m_sdiv[y]))
				{
					table[1]--;

					break;
				}

		/* Определяем наименьший первообразный корень обрабатываемого числа
		 *
		 * (в данном случае используется неэффективный, но наиболее простой в реализации, метод -
		 * последовательное возведение в степень с основанием, равным значению функции Эйлера, по модулю, равному обрабатываемому числу,
		 * каждого числа, начиная с двойки, до тех пор, пока не будет найдено число, результат от возведения в степень которого будет равен 1) */
		for(x = 2; x < table[0]; x++)
		{
			u = x;

			for(y = (table[1] - 1); y > 0; y--)
				u = (u * x) % table[0];

			if(u == 1)
			{
				table[2] = x;

				break;
			}
		}

		/* Вычисляем значение ячеек таблицы "индекс -> число"
		 *
		 * (в результирующем массиве данная таблица будет расположена построчно, начиная с верхней строки, со смещением начала таблицы
		 * от начала массива равным 3-м) */
		table[3] = 1;
		table[4] = table[2];

		for(x = 5; x < (table[0] + 3); x++)
			table[x] = (table[x - 1] * table[2]) % table[0];
	}

	/* Исключительно для иллюстрации возможностей функции pthread_exit():
	 *
	 *		Если функция rand() сгенерировала нечетное случайное целое - завершаем поток функцией pthread_exit()
	 *
	 *		Если функция rand() сгенерировала четное случайное целое - завершаем поток возвратом из главной функции потока */
	if(rand() % 2)
		pthread_exit(table);
	
	return table;
}

