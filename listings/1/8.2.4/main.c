
#include <stdio.h>

#include <signal.h>			/* Для signal() */
#include <unistd.h>			/* Для fork() и getpid() */
#include <sys/types.h>		/* Для waitpid() */
#include <wait.h>
#include <stdlib.h>			/* Для malloc() и free() */
#include <malloc.h>			/* Для mallopt() и mallinfo() */

/* Функция M_CHECK_ACTION_check() проверяет эффект от изменения значения параметра M_CHECK_ACTION алгоритма выделения динамической памяти */
void M_CHECK_ACTION_check();

/* Функция M_MMAP_THRESHOLD_check() проверяет эффект от изменения значения параметра M_MMAP_THRESHOLD алгоритма выделения динамической памяти */
void M_MMAP_THRESHOLD_check();

/* Функция - обработчик сигнала SIGABRT главным процессом программы и всеми его дочерними процессами */
void SIGABRT_proc()
{
	fprintf(stderr, "получен сигнал SIGABRT процессом, PID которого равен %d\n\n", getpid());

	exit(0);
}

/* Главная функция программы */
int main()
{
	printf("\n");

	printf("Настройка параметра M_CHECK_ACTION алгоритма выделения динамической памяти\n\n");

	/* Проверяем эффект от изменения значения параметра M_CHECK_ACTION алгоритма выделения динамической памяти */
	M_CHECK_ACTION_check();

	printf("Настройка параметра M_MMAP_THRESHOLD алгоритма выделения динамической памяти\n\n");

	/* Проверяем эффект от изменения значения параметра M_MMAP_THRESHOLD алгоритма выделения динамической памяти */
	M_MMAP_THRESHOLD_check();

	printf("\n");

	return 0;
}

/* Функция M_CHECK_ACTION_check() проверяет эффект от изменения значения параметра M_CHECK_ACTION алгоритма выделения динамической памяти */
void M_CHECK_ACTION_check()
{
	/* Устанавливаем функцию SIGABRT_proc() как обработчик для сигнала SIGABRT -
	 * назначение обработчиков сигналов наследуется дочерними процессами */
	if(
		signal(SIGABRT, & SIGABRT_proc) == SIG_ERR
	  )
		perror("Ошибка при установке функции - обработчика сигнала SIGABRT");
	else
	{
		int x, child, status;

		/* Запускаем два дочерних процесса:
		 *
		 *		Первый (x == 1) проверит эффект от установки значения параметра M_CHECK_ACTION в 1
		 *
		 *		Второй (x == 2) проверит эффект от установки значения параметра M_CHECK_ACTION в 2
		 *
		 * Теоретические результаты:
		 *
		 *		Первый процесс (M_CHECK_ACTION == 1) при выполнении free() относительно некорректного адреса получит от ОС предупреждение
		 *		                                     в стандартный поток ошибок
		 *
		 *		Второй процесс (M_CHECK_ACTION == 2) при выполнении free() относительно некорректного адреса получит от ОС сигнал SIGABRT
		 */
		for(x = 1; x < 3; x++)
		{
			/* Запускаем очередной дочерний процесс */
			if(
				(child = fork()) == -1
			  )
				perror("Ошибка при запуске дочернего процесса");
			else if(child)
			{
				/* Мы в родительском процессе */

				/* Родительский процесс ожидает завершения (WIFEXITED) дочернего процесса с PID == child */
				do
					waitpid(child, & status, 0);
				while(! WIFEXITED(status));
			}
			else
			{
				/* Мы в дочернем процессе */

				printf("\tЗапущен дочерний процесс с PID == %d\n", getpid());

				printf("\tУстановка параметра M_CHECK_ACTION в значение %d\n", x);

				/* Вызовом функции mallopt() устанавливаем значение параметра M_CHECK_ACTION алгоритма выделения динамической памяти
				 * относительно дочернего процесса в значение переменной x */
				if(
					mallopt(M_CHECK_ACTION, x) == -1
				  )
					perror("Ошибка при изменении параметра M_CHECK_ACTION алгоритма выделения динамической памяти");

				printf("\tВызов функции free() с некорректным адресом возвращаемой ОС области виртуального адресного пространства процесса\n");
				
				fprintf(stderr, "\tРеакция ОС: ");

				int temp;

				/* Пытаемся освободить невыделенную ранее вызовом функций malloc(), calloc(), realloc(), posix_memalign() и тому подобными
				 * область виртуального адресного пространства процесса - очевидная ошибка, предупреждение о которой ОС сделает процессу
				 * в соответствии со значением параметра M_CHECK_ACTION */
				free(& temp);

				printf("\n");

				/* Завершение дочернего процесса */
				exit(0);
			}
		}
	}
}

/* Функция M_MMAP_THRESHOLD_check() проверяет эффект от изменения значения параметра M_MMAP_THRESHOLD алгоритма выделения динамической памяти */
void M_MMAP_THRESHOLD_check()
{
	int x, child, status;

	/* Последовательно запускаем два дочерних процесса
	 *
	 *		Первый (x == 0) в качестве значения параметра M_MMAP_THRESHOLD оставит значение по умолчанию - 128 килобайт
	 *
	 *		Второй (x == 1) в качестве значения параметра M_MMAP_THRESHOLD установит 256 килобайт
	 *
	 *		Оба процесса запросят у ОС выделение области своего виртуального адресного пространства размером 256 килобайт
	 *
	 *		Оба процесса вызовом функции mallinfo() получат статистическую информацию о выделенной им динамической памяти -
	 *		нас интересует поле hblks структуры данных mallinfo, содержащее количество анонимных отображений, которыми удовлетворены
	 *		запросы процесса на выделение ему областей его виртуального адресного пространства 
	 *
	 * Теоретические результаты:
	 *
	 *		Первый процесс (x == 0) hblks == 1 (так как 256 > 128 и выделение области виртуального адресного пространства размером 256 килобайт
	 *		произойдет созданием анонимного отображения)
	 *
	 *		Второй процесс (x == 1) hblks == 0 (так как 256 < 512 и выделение области виртуального адресного пространства размером 256 килобайт
	 *		произойдет в куче)
	 */
	for(x = 0; x < 2; x++)
	{
		/* Запускаем очередной дочерний процесс */
		if(
			(child = fork()) == -1
		  )
			perror("Ошибка при запуске дочернего процесса");
		else if(child)
		{
			/* Мы в родительском процессе */

			/* Родительский процесс ожидает завершения (WIFEXITED) дочернего процесса с PID == child */
			do
				waitpid(child, & status, 0);
			while(! WIFEXITED(status));
		}
		else
		{
			/* Мы в дочернем процессе */

			printf("\tЗапущен дочерний процесс с PID == %d\n", getpid());

			/* Если x == 1 (второй дочерний процесс), то устанавливаем значение параметра M_MMAP_THRESHOLD алгоритма выделения
			 * динамической памяти в 512 килобайт */
			if(
				x
				&&
				mallopt(M_MMAP_THRESHOLD, 512 * 1024) == -1
			  )
				perror("Ошибка при изменении параметра M_MMAP_THRESHOLD алгоритма выделения динамической памяти");

			printf("\tЗначение параметра M_MMAP_THRESHOLD: %u килобайт\n", x ? 512 : 128);

			printf("\tВыделение процессу области его виртуального адресного пространства размером 256 килобайт\n");

			/* Запрашиваем у ОС выделение процессу области его виртуального адресного пространства размером 256 килобайт */
			void *ptr = malloc(256 * 1024);

			if(ptr == NULL)
				perror("Ошибка при выделении дочернему процессу 256-и килобайтной области его виртуального адресного пространства");
			else
			{
				/* Область виртуального адресного пространства процесса успешно ему выделена */

				/* Получаем статистическую информацию о выделенной процессу динамической памяти */
				struct mallinfo mi = mallinfo();

				/* Проверяем значение поля hblks экземпляра структуры данных mallinfo */
				printf("\tЧисло анонимных отображений, использованных для удовлетворения запросов выделения динамической памяти: %d\n", mi.hblks);

				printf("\tОсвобождение выделенной области виртуального адресного пространства процесса\n\n");

				/* Освобождаем выделенную раннее область виртуального адресного пространства процесса */
				free(ptr);
			}

			exit(0);
		}
	}
}

