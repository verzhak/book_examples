
#define _GNU_SOURCE		/* Для dprintf() */

#include <stdio.h>
#include <string.h>

#include <errno.h>		/* Для errno */
#include <unistd.h>		/* Для mincore() */
#include <sys/mman.h>	/* Для mlockall(), munlockall(), mmap() и munmap() */

/* Функция mem_lock_unlock_all() выполняет следующие действия:
 *
 *		1. Создает первое анонимное отображение
 *		2. Блокирует страницы виртуального адресного пространства процесса вызовом функции mlockall(), передав ей битовую маску флагов,
 *		   указанную параметром flags
 *		3. Создает второе анонимное отображение
 *		4. Вызовом функции print_incore() проверяет, какие страницы каждого из анонимных отображений присутствуют в оперативной памяти
 *
 *		   Теоретические результаты:
 *
 *				flags == MCL_CURRENT
 *
 *					Страницы первого анонимного отображения (действительные на момент вызова функции mlockall()) присутствуют в оперативной памяти
 *					Страницы второго анонимного отображения (которое, на момент вызова mlockall(), еще не существовало) отсутствуют в оперативной памяти
 *
 *				flags == (MCL_CURRENT | MCL_FUTURE)
 *
 *					Страницы первого анонимного отображения (действительные на момент вызова функции mlockall()) присутствуют в оперативной памяти
 *					Страницы второго анонимного отображения (которое, на момент вызова mlockall(), еще не существовало) присутствуют в оперативной памяти
 *
 *		5. Удаляет второе анонимное отображение
 *		6. Вызовом функции munlockall() разблокирует сброс в swap страниц виртуального адресного пространства процесса
 *		7. Удаляет первое анонимное отображение
 *
 *	Причина использования анонимных отображений:
 *
 *		Анонимные отображения (как и файловые отображения) создаются в виде отдельных сегментов виртуального адресного пространства процесса - таким образом,
 *		мы гарантируем, что страницы виртуального адресного пространства процесса, занимаемые после вызова mmap() анонимными отображениями, являются
 *		недействительными до вызова mmap().
 *
 *		В случае выделения памяти с помощью функций malloc(), calloc(), realloc() или posix_memalign() выделяемые процессу области его виртуального
 *		адресного пространства расположены в куче (сегменте данных) и потенциально (особенно в "не первых" вызовах функции mem_lock_unlock_all()) содержат
 *		действительные (но свободные) страницы еще до выполнения вызовов означенных функций - таким образом, даже при использовании флага MCL_CURRENT,
 *		блокированной от сброса в swap может оказаться область виртуального адресного пространства процесса, выделяемая после вызова функции mlockall()
 *
 *		Вывод:
 *			
 *			Используя анонимные отображения, мы соблюдаем чистоту эксперимента
 */
void mem_lock_unlock_all(int flags);

/* Функция print_incore() проверяет с помощью функции mincore(), какие из page_num страниц виртуального адресного пространства процесса,
 * начиная со страницы, расположенной по адресу ptr, присутствуют в оперативной памяти */
void print_incore(void *ptr, unsigned short page_num);

/* Главная функция программы */
int main()
{
	printf("\n---> Блокирование сброса в swap только действительных на момент вызова mlockall() страниц виртуального адресного пространства процесса \
(MCL_CURRENT)\n\n");

	/* Вызываем функцию mem_lock_unlock_all(), предписывая той выполнить вызов функции mlockall() с битовой маской флагов == MCL_CURRENT */
	mem_lock_unlock_all(MCL_CURRENT);

	printf("---> Блокирование сброса в swap всех страниц виртуального адресного пространства процесса (MCL_CURRENT | MCL_FUTURE)\n\n");

	/* Вызываем функцию mem_lock_unlock_all(), предписывая той выполнить вызов функции mlockall() с битовой маской флагов == (MCL_CURRENT | MCL_FUTURE) */
	mem_lock_unlock_all(MCL_CURRENT | MCL_FUTURE);

	return 0;
}

/* Функция mem_lock_unlock_all() выполняет вызовы функций mlockall() и munlockall() */
void mem_lock_unlock_all(int flags)
{
	/* Константа компилятора PAGE_NUM содержит количество страниц, занимаемых обоими создаваемыми анонимными отображениями */
#define PAGE_NUM 5

	void *ptr[2];

	/* Переменная ptr_size содержит размер в байтах обоих создаваемых анонимных отображений */
	size_t ptr_size = PAGE_NUM * 4096;

	printf("\t---> Выделение процессу анонимным отображением %u-и страниц его виртуального адресного пространства\n", PAGE_NUM);

	/* Предписываем ОС создать первое анонимное отображение
	 *
	 * Размер: ptr_size байт
	 * Защита: (PROT_READ | PROT_WRITE) - доступны чтение и запись
	 * Флаги:  (MAP_PRIVATE | MAP_ANONYMOUS) - не разделяемое, анонимное отображение */
	if(
		(ptr[0] = mmap(NULL, ptr_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) == MAP_FAILED
	  )
		dprintf(2, "\n\tОшибка при создании анонимного отображения: %s\n\n", strerror(errno));
	else
	{
		printf("\t---> Блокирование сброса в swap страниц виртуального адресного пространства процесса с помощью функции mlockall()\n");

		/* Блокируем сброс в swap страниц виртуального адресного пространства процесса */
		if(
			mlockall(flags) == -1
		  )
		{
			/* Ошибка с кодом ENOMEM произойдет в случае, если процесс не имеет характеристику CAP_IPC_LOCK и превысил мягкий лимит RLIMIT_MEMLOCK */
			if(errno == ENOMEM)
				dprintf(2, "\n\tОшибка при блокировании сброса в swap страниц виртуального адресного пространства процесса:\n\t\t\
Процесс не имеет характеристики CAP_IPC_LOCK и превысил мягкий лимит RLIMIT_MEMLOCK\n\n");
			else
				dprintf(2, "\tОшибка при блокировании сброса в swap всех страниц виртуального адресного пространства процесса: %s\n",
						strerror(errno));
		}
		else
		{
			printf("\t---> Выделение процессу анонимным отображением %u-и страниц его виртуального адресного пространства\n", PAGE_NUM);

			/* Предписываем ОС создать второе анонимное отображение
			 *
			 * Размер: ptr_size байт
			 * Защита: (PROT_READ | PROT_WRITE) - доступны чтение и запись
			 * Флаги:  (MAP_PRIVATE | MAP_ANONYMOUS) - не разделяемое, анонимное отображение */
			if(
				(ptr[1] = mmap(NULL, ptr_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)) == MAP_FAILED
			  )
				dprintf(2, "\n\tОшибка при создании анонимного отображения: %s\n\n", strerror(errno));
			else
			{
				printf("\t---> Проверка нахождения в оперативной памяти страниц первого анонимного отображения\n\n");

				/* Проверяем, какие страницы первого анонимного отображения присутствуют в оперативной памяти */
				print_incore(ptr[0], PAGE_NUM);

				printf("\t---> Проверка нахождения в оперативной памяти страниц второго анонимного отображения\n\n");

				/* Проверяем, какие страницы второго анонимного отображения присутствуют в оперативной памяти */
				print_incore(ptr[1], PAGE_NUM);

				printf("\t---> Удаление второго анонимного отображения\n");

				/* Удаляем второе анонимное отображение */
				munmap(ptr[1], ptr_size);
			}

			printf("\t---> Разблокирование сброса в swap страниц виртуального адресного пространства процесса с помощью функции munlockall()\n");

			/* Разблокируем сброс в swap страниц виртуального адресного пространства процесса */
			if(
				munlockall() == -1
			  )
				dprintf(2, "\n\tОшибка при разблокировании сброса в swap всех страниц виртуального адресного пространства процесса: %s\n\n",
						strerror(errno));
		}

		printf("\t---> Удаление первого анонимного отображения\n\n");

		/* Удаляем первое анонимное отображение */
		munmap(ptr[0], ptr_size);
	}
}

/* Функция print_incore() проверяет с помощью функции mincore(), какие из page_num страниц виртуального адресного пространства процесса,
 * начиная со страницы, расположенной по адресу ptr, присутствуют в оперативной памяти */
void print_incore(void *ptr, unsigned short page_num)
{
	/* Следуя рекомендациям документации, массив vec будет иметь размер (page_num + 1) элементов */
	unsigned char vec[page_num + 1];

	/* Проверяем, какие из page_num страниц виртуального адресного пространства процесса,
	 * начиная со страницы, расположенной по адресу ptr, присутствуют в оперативной памяти */
	if(
		mincore(ptr, page_num * 4096, vec) == -1
	  )
		perror("\t\tОшибка при получении информации о страницах виртуального адресного пространства процесса, находящихся в оперативной памяти");
	else
	{
		/* Функция mincore() успешно вернула требуемую информацию в массиве vec */

		int x;

		/* Для каждой из страниц виртуального адресного пространства процесса из заданного диапазона,
		 * присутствующих в оперативной памяти, выведем соответствующее сообщение */
		for(x = 0; x < page_num; x++)
			if(vec[x])
				printf("\t\tСтраница %d находится в оперативной памяти\n", x + 1);

		printf("\n");
	}
}

