
/* Пример использования функций getrlimit() и setrlimit() для получения значений и установления значений лимитов соответственно
 *
 * Алгоритм работы программы:
 *		
 *		1) Родительский процесс запускает дочерний процесс
 *		2) Родительский процесс ожидает завершение дочернего процесса
 *			1) Дочерний процесс выводит в стандартный поток вывода информацию о своих значениях лимитов RLIMIT_CORE (максимальный
 *			   размер core-файла) и RLIMIT_STACK (размер стека)
 *			2) Дочерний процесс устанавливает значения мягких лимитов RLIMIT_CORE и RLIMIT_STACK в значения:
 *				RLIMIT_CORE - 4 килобайта (при аварийном завершении дочернего процесса ОС создаст для дочернего процесса core-файл размером до 4-х килобайт
 *							  в текущем для процесса на момент его завершения каталоге)
 *				RLIMIT_STACK - 11 мегабайт
 *			3) Дочерний процесс выводит в стандартный поток вывода информацию о своих значениях лимитов RLIMIT_CORE (максимальный
 *			   размер core-файла) и RLIMIT_STACK (размер стека)
 *			4) Дочерний процесс вызывает переполнение стека => аварийно завершается => ОС создает в отношении дочернего процесса core-файл
 *		3) Родительский процесс предписывает командному интерпретатору вывести в стандартный поток вывода информацию о core-файле дочернего процесса.
 *		   Вывод информации производится с помощью утилиты readelf, запущенной с ключом "-h"
 *		4) Родительский процесс удаляет core-файл дочернего процесса
 *
 * Данную программу необходимо компилировать командой:
 *
 *		gcc -masm=intel main.c
 */

#include <stdio.h>

#include <unistd.h>			/* Для fork() */
#include <sys/types.h>		/* Для wait() */
#include <sys/wait.h>
#include <stdlib.h>			/* Для malloc(), free() */
#include <sys/time.h>		/* Для getrlimit(), setrlimit() */
#include <sys/resource.h>

/* Функция my_printlim() выводит мягкое и жесткое значения лимита lim, предваряя вывод строкой info
 *
 * В случае, если в параметре is_ret передано ненулевое значение, то my_printlim() возвращает в вызывающую
 * подпрограмму информацию о мягком и жестком значениях целевого лимита. Если же в параметре is_ret передан 0,
 * то данная функция возвращает нулевой указатель (NULL) */
struct rlimit * my_printlim(int lim, const char *info, short is_ret);

int main()
{
	printf("\n");

	/* Запускаем дочерний процесс */
	int child = fork();

	if(child == -1)
	{
		perror("Ошибка при запуске дочернего процесса");

		return -1;
	}
	else if(child)
	{
		/* Мы в родительском процессе */

		int status;

		/* Родительский процесс ожидает завершение (единственного) дочернего процесса. Информация об обстоятельствах
		 * завершения дочернего процесса сохраняется в переменной status */
		wait(& status);

		printf("---> Дочерний процесс завершился\n");

		/* Проверяем, завершился ли дочерний процесс с созданием core-файла */
		if(WCOREDUMP(status))
		{
			/* По завершении дочернего процесса был создан core-файл */

			printf("---> ОС создала core-файл (файл дампа памяти) по завершении дочернего процесса\n\n");
			
			printf("######################################################################\nИнформация о core-файле дочернего процесса\n\
(информация получена с помощью утилиты readelf)\n\n");

			/* С помощью утилиты readelf выводим информацию о core-файле */
			system("readelf -h ./core");

			printf("\n######################################################################\n\n");

			printf("---> Удаляем core-файл дочернего процесса\n\n");

			/* Удаляем core-файл */
			if(
				unlink("./core") == -1
			  )
				perror("Ошибка при удалении core-файла");
		}
	}
	else
	{
		/* Мы в дочернем процессе */

		struct rlimit *lim_stack, *lim_core;

		printf("---> (дочерний процесс) Получаем информацию о лимитах RLIMIT_CORE и RLIMIT_STACK\n\n");

		/* Выводим в стандартный поток вывода и получаем в качестве возвращенного значения из функции my_printlim()
		 * значения лимитов RLIMIT_CORE и RLIMIT_STACK */
		if(
			(lim_core = my_printlim(RLIMIT_CORE, "RLIMIT_CORE (максимальный размер core-файла)", 1)) == NULL
			||
			(lim_stack = my_printlim(RLIMIT_STACK, "RLIMIT_STACK (максимальный размер стека процесса)", 1)) == NULL
		  )
			perror("Ошибка при получении значений лимитов RLIMIT_CORE и(или) RLIMIT_STACK");
		else
		{
			lim_core->rlim_cur = 4096;
			lim_stack->rlim_cur = 11 * (1024 * 1024);

			printf("\n---> (дочерний процесс) Устанавливаем мягкие лимиты RLIMIT_CORE и RLIMIT_STACK\n");

			/* Устанавливаем новые значения мягких лимитов RLIMIT_CORE и RLIMIT_STACK */ 
			if(
				setrlimit(RLIMIT_CORE, lim_core) == -1
				||
				setrlimit(RLIMIT_STACK, lim_stack) == -1
			  )
			{
				perror("Ошибка при установлении мягких лимитов RLIMIT_CORE и RLIMIT_STACK");
				
				free(lim_core);
				free(lim_stack);
			}
			else
			{
				printf("---> (дочерний процесс) Получаем информацию о лимитах RLIMIT_CORE и RLIMIT_STACK\n\n");

				/* Выводим в стандартный поток вывода значения лимитов RLIMIT_CORE и RLIMIT_STACK */
				my_printlim(RLIMIT_CORE, "RLIMIT_CORE (максимальный размер core-файла)", 0);
				my_printlim(RLIMIT_STACK, "RLIMIT_STACK (максимальный размер стека процесса)", 0);

				free(lim_core);
				free(lim_stack);

				printf("\n---> (дочерний процесс) Вызываем переполнение стека\n");

				/* Вызываем переполнение стека - увеличиваем значение регистра esp на число, заведомо превосходящее
				 * размер стека и выполняем push (чтобы ОС наверняка обратила внимание на ненормальное значение указателя стека) */
				__asm(".intel_syntax noprefix\n\
						add esp, 100000000\n\
						push 1234567");

				printf("### Это сообщение появится в стандартном потоке вывода не должно ###\n");
			}
		}
	}

	return 0;
}

/* Функция my_printlim() выводит мягкое и жесткое значения лимита lim, предваряя вывод строкой info
 *
 * В случае, если в параметре is_ret передано ненулевое значение, то my_printlim() возвращает в вызывающую
 * подпрограмму информацию о мягком и жестком значениях целевого лимита. Если же в параметре is_ret передан 0,
 * то данная функция возвращает нулевой указатель (NULL) */
struct rlimit * my_printlim(int lim, const char *info, short is_ret)
{
	/* Если is_ret не ноль, то значение lim_value будет возвращено в вызывающую функцию подпрограмму,
	 * иначе (is_ret == 0) lim_value - самый обычный промежуточный буфер */
	struct rlimit *lim_value = (struct rlimit *) malloc(sizeof(struct rlimit));

	if(
		lim_value == NULL
		||
		/* Получаем мягкое и жесткое значение лимита lim */
		getrlimit(lim, lim_value) == -1
	  )
		return NULL;

	printf("Лимиты %s: [мягкий лимит = ", info);

	if(
		lim_value->rlim_cur == RLIM_INFINITY
	  )
		printf("%s", "RLIMIT_INFINITY");
	else
		printf("%lu байт = %.1f мегабайт", lim_value->rlim_cur, lim_value->rlim_cur / (1024.0 * 1024.0));

	printf(", жесткий лимит = ");

	if(
		lim_value->rlim_max == RLIM_INFINITY
	  )
		printf("%s", "RLIMIT_INFINITY");
	else
		printf("%lu байт = %.1f мегабайт", lim_value->rlim_max, lim_value->rlim_max / (1024.0 * 1024.0));

	printf("]\n");

	if(is_ret)
		return lim_value;
	
	free(lim_value);
	
	return NULL;
}

