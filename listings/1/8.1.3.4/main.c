
#define _GNU_SOURCE				/* Для dprintf() */

#include <stdio.h>
#include <string.h>

#include <stdlib.h>				/* Для posix_memalign() */
#include <errno.h>				/* Для errno */
#include <sys/time.h>			/* Для getrlimit() */
#include <sys/resource.h>
#include <unistd.h>				/* Для mincore() */
#include <sys/mman.h>			/* Для mlock() и munlock() */

/* Функция print_incore() проверяет с помощью функции mincore(), какие из page_num страниц виртуального адресного пространства процесса,
 * начиная со страницы, расположенной по адресу ptr, присутствуют в оперативной памяти */
void print_incore(void *ptr, unsigned short page_num);

/* Главная функция программы */
int main()
{
	size_t ptr_size;
	struct rlimit memlock_lim;

	printf("\n---> Получение информации о мягком лимите RLIMIT_MEMLOCK\n\n");

	/* Получаем информацию о мягком и жестком лимитах RLIMIT_MEMLOCK - нам необходимо значение мягкого лимита RLIMIT_MEMLOCK
	 * как ограничение на суммарный размер в байтах областей виртуального адресного пространства процесса,
	 * сброс которых в swap мы можем заблокировать */
	if(
		getrlimit(RLIMIT_MEMLOCK, & memlock_lim) == -1
	  )
	{
		/* Получение мягкого и жесткого лимитов RLIMIT_MEMLOCK завершилось неудачей */

		perror("Ошибка при получении значений мягкого и жесткого лимитов RLIMIT_MEMLOCK");

		/* Переменная ptr_size будет хранить размер выделяемой ОС процессу области его виртуального адресного пространства -
		 * выделим процессу на страницу больше, чем значение по умолчанию мягкого лимита RLIMIT_MEMLOCK,
		 * чтобы впоследствии проверить выполнение системой ограничений, вводимых данным лимитом */
		ptr_size = 17 * 4096;
	}
	else
	{
		/* Значение мягкого и жесткого лимитов RLIMIT_MEMLOCK успешно получено */

		/* Переменная ptr_size будет хранить размер выделяемой ОС процессу области его виртуального адресного пространства -
		 * выделим процессу на страницу больше, чем значение мягкого лимита RLIMIT_MEMLOCK,
		 * чтобы впоследствии проверить выполнение системой ограничений, вводимых данным лимитом */
		ptr_size = memlock_lim.rlim_cur + 4096;
		
		printf("---> Мягкий лимит RLIMIT_MEMLOCK: %lu байт = %lu килобайт = %lu страниц\n\n",
				memlock_lim.rlim_cur, memlock_lim.rlim_cur / 1024, memlock_lim.rlim_cur / 4096);
	}

	printf("---> Выделение процессу %u байт = %u килобайт = %u страниц динамической памяти\n\n", ptr_size, ptr_size / 1024, ptr_size / 4096);

	void *ptr;

	/* Предписываем ОС выделить процессу выровненную по размеру страницы область его виртуального адресного пространства размером ptr_size байт -
	 * выравнивание необходимо, чтобы в дальнейшем при вызове функции mincore() не заботится о кратном по размеру страницы значении первого параметра */
	if(
		posix_memalign(& ptr, 4096, ptr_size) == -1
		)
		perror("Ошибка при выделении динамической памяти");
	else
	{
		printf("---> Блокирование от сброса в swap 20480 байт = 20 килобайт = 5 страниц виртуального адресного пространства процесса\n\n");

		/* Пробуем заблокировать от сброса в swap 5 выделенных ранее страниц -
		 * функция mlock() должна завершится успехом, так как, что наиболее вероятно, значение мягкого лимита RLIMIT_MEMLOCK больше пяти страниц */
		if(
			mlock(ptr, 5 * 4096) == -1
		  )
			perror("Ошибка при блокировании сбрасывания в swap 5 страниц виртуального адресного пространства процесса");
		else
		{
			/* Проверяем, какие страницы из выделенной области виртуального адресного пространства процесса присутствуют в оперативной памяти
			 *
			 * Прогнозируемый результат: первые пять страниц. Действительно, единственное обращение к выделенным страницам происходило
			 * при блокировке от сбрасывания в swap первых пяти страниц, обращения же к остальным страницам не было - очевидно, что ОС,
			 * оптимизируя выделение динамической памяти, отложила реальное выделение данных страниц и, соответственно, нет причин для их
			 * нахождения в оперативной памяти */
			print_incore(ptr, ptr_size / 4096);

			printf("---> Разблокирование сброса в swap 20480 байт = 20 килобайт = 5 страниц виртуального адресного пространства процесса\n\n");

			/* Разблокируем сброс в swap первых пяти страниц выделенной области виртуального адресного пространства процесса */
			if(
				munlock(ptr, 5 * 4096) == -1
				)
				perror("Ошибка при разблокировании сбрасывания в swap 5 страниц виртуального адресного пространства процесса");
		}

		printf("---> Блокирование от сброса в swap %u байт = %u килобайт = %u страниц виртуального адресного пространства процесса\n\n",
				ptr_size, ptr_size / 1024, ptr_size / 4096);

		/* Пробуем заблокировать от сброса в swap все, выделенные процессу вызовом функции posix_memalign(), страницы его
		 * виртуального адресного пространства - функция mlock() должна завершится:
		 *
		 *		1. Неудачей, если процесс не имеет характеристики CAP_IPC_LOCK, так как значение ptr_size превосходит
		 *		   значение мягкого лимита RLIMIT_MEMLOCK
		 *
		 *		2. Успехом, если процесс имеет характеристику CAP_IPC_LOCK (например, запущен суперпользователем) */
		if(
			mlock(ptr, ptr_size) == -1
		  )
		{
			dprintf(2, "Ошибка при блокировании сбрасывания в swap %u-и страниц виртуального адресного пространства процесса:\n",
					ptr_size / 4096);

			/* Если errno имеет значение ENOMEM, то mlock() завершился неудачей из-за того, что ptr_size превосходит
			 * значение мягкого лимита RLIMIT_MEMLOCK */
			if(errno == ENOMEM)
				printf("\tПроцесс не обладает характеристикой CAP_IPC_LOCK и превысил мягкий лимит RLIMIT_MEMLOCK\n\n");
			else
				printf("\t%s\n\n", strerror(errno));	
		}
		else
		{
			/* Проверяем, какие страницы из выделенной области виртуального адресного пространства процесса присутствуют в оперативной памяти */
			print_incore(ptr, ptr_size / 4096);

			printf("---> Разблокирование сброса в swap %u байт = %u килобайт = %u страниц виртуального адресного пространства процесса\n\n",
					ptr_size, ptr_size / 1024, ptr_size / 4096);

			/* Разблокируем сброс в swap страниц выделенной процессу области его виртуального адресного пространства */
			if(
				munlock(ptr, ptr_size) == -1
				)
				dprintf(2, "Ошибка при разблокировании сбрасывания в swap %u-и страниц виртуального адресного пространства процесса:\n\t%s\n\n",
						ptr_size / 4096, strerror(errno));
		}

		printf("---> Освобождение выделенной процессу динамической памяти\n");

		/* Освободим выделенную ранее область виртуального адресного пространства процесса */
		free(ptr);
	}

	printf("\n");

	return 0;
}

/* Функция print_incore() проверяет с помощью функции mincore(), какие из page_num страниц виртуального адресного пространства процесса,
 * начиная со страницы, расположенной по адресу ptr, присутствуют в оперативной памяти */
void print_incore(void *ptr, unsigned short page_num)
{
	/* Следуя рекомендациям документации, массив vec будет иметь размер (page_num + 1) элементов */
	unsigned char vec[page_num + 1];

	/* Проверяем, какие из page_num страниц виртуального адресного пространства процесса,
	 * начиная со страницы, расположенной по адресу ptr, присутствуют в оперативной памяти */
	if(
		mincore(ptr, page_num * 4096, vec) == -1
	  )
		perror("Ошибка при получении информации о страницах виртуального адресного пространства процесса, находящихся в ОП");
	else
	{
		/* Функция mincore() успешно вернула требуемую информацию в массиве vec */

		int x;

		/* Для каждой из страниц виртуального адресного пространства процесса из заданного диапазона,
		 * присутствующих в оперативной памяти, выведем соответствующее сообщение */
		for(x = 0; x < page_num; x++)
			if(vec[x])
				printf("Страница %d присутствует в оперативной памяти\n", x + 1);

		printf("\n");
	}
}

