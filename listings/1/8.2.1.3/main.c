
#include <stdio.h>

#include <stdint.h>
#include <stdlib.h>		/* Для posix_memalign() и free() */

int main()
{
	printf("\n");

	void *ptr;
	size_t x, align;

	/* Именованная константа buf_size будет иметь своим значением размер в байтах выделяемых буферов -
	 * 1024 байта */
	const size_t buf_size = 1024;

	/* Для выравниваний от 0x4 до 0x4000 включительно повторять, сдвигая каждый раз единственную единицу в переменной
	 * align, хранящей выравнивание, влево на один бит
	 *
	 * (условие выполнение цикла - (align & 0x7FFF) - эффективнее, чем (align < 0x8000), так как в первом случае имеем
	 * инструкцию test, а во втором - cmp, потенциально более медленную) */
	for(align = 4; align & 0x7FFF; align <<= 1)
	{
		printf("Выделение выровненной по 0x%X области виртуального адресного пространства процесса", align);

		/* Предписываем ОС выделить процессу выровненную по align область виртуального адресного пространства процесса размером buf_size байт,
		 * поместив при этом адрес выделенной области виртуального адресного пространства в переменную ptr */
		if(
			posix_memalign(& ptr, align, buf_size) == -1
		  )
			perror("\nОшибка при выделении выровненной области памяти\n");
		else
		{
			/* Проверяем, выполнено ли требование по выравниванию адреса выделенной процессу области его виртуального адресного пространства -
			 * для этого значение указателя ptr приводим к типу uint32_t (предполагается, что пример выполняется на процессоре архитектуры ia32 =>
			 * используются 32-х битные адреса памяти) и находим остаток от деления ptr на align - если остаток не ноль,
			 * то требование по выравниванию не выполнено и наоборот - если остаток ноль, то требование по выравниванию выполнено */
			printf(" [Выравнивание выполнено? %s]\n", ((uint32_t) ptr) % align ? "Нет" : "Да");

			printf("Заполнение выделенной области памяти случайными данными - ");

			/* Заполняем выделенную область виртуального адресного пространства процесса случайными данными -
			 * заполнение не вызовет ошибки сегментирования (то есть процессу не придет сигнал SIGSEGV,
			 * ведущий к завершению процесса), если динамическая память выделена корректно */
			for(x = 0; x < buf_size; x++)
				((char *) ptr)[x] = rand() % 256;

			printf("Освобождение с помощью функции free() выделенной процессу динамической памяти\n\n");

			/* Освобождаем выделенную процессу динамическую память */
			free(ptr);
		}
	}

	return 0;
}

