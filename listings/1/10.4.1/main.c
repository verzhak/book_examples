
#define _GNU_SOURCE

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

#include <signal.h>		/* Для kill() */
#include <wait.h>		/* Для wait() */
#include <sys/types.h>	/* Для open(), close(), write() */
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <sys/mman.h>	/* Для mmap(), munmap() */

int main()
{
	int x;

	/* ############################################################################# */
	/* Создадим файл достаточного размера (2048 байт) */

	/* Анонимное неразделяемое отображение
	 * (фактически, область памяти - размером 4096 байт, доступная только для чтения, заполненная нулями) */
	void *addr = mmap(NULL, 2048, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

	if(addr == MAP_FAILED)
	{
		perror("Ошибка при создании анонимного отображения");
		return -1;
	}

	/* Открываем на чтение/запись новый временный файл */
	char name[] = "/tmp/kursXXXXXXX";	/* XXXXXX будут заменены на уникальный суффикс */
	int fd = mkostemp(name, O_TRUNC | O_RDWR);

	if(fd == -1)
	{
		perror("Ошибка при создании / открытии файла");
		return -1;
	}

	/* Записываем в файл 2048 нулей */
	if(
			write(fd, addr, 2048) < 2048
	  )
	{
		perror("Ошибка - в целевой файл было записано менее 2048 байт");
		close(fd);
		return -1;
	}

	/* Удаляем анонимное отображение */
	if(
			munmap(addr, 2048) == -1
	  )
		perror("Ошибка при удалении анонимного отображения");

	/* ############################################################################ */
	/* Взаимодействие двух процессов */

	/* Запускаем дочерний процесс до того, как отобразим файл в память
	 * (гарантируя таким образом то, что дочерний процесс не унаследует указатель
	 * на разделяемое отображение - для чистоты эксперимента) */
	int child = fork();

	if(child == -1)
		perror("Ошибка при создании дочернего процесса");
	else if(child)
	{
		/* Мы в родительском процессе */

		/* Отображаем файл в память */
		addr = mmap(NULL, 2048, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

		int old_errno = errno;	/* close() сбросит значение errno, а оно еще пригодиться */

		/* Закрываем дескриптор файла */
		close(fd);

		if(addr == MAP_FAILED)
		{
			fprintf(stderr, "Ошибка при отображении файла в память: %s\n", strerror(old_errno));

			kill(child, SIGTERM);	/* Дочерний процесс не дождется установки ожидаемого им флага */

			return -1;
		}

		/* В байты [1; 2047] файла пишем случайные символы */
		for(x = 1; x < 2048; x++)
			((char *) addr)[x] = 'A' + rand() % 26;

		/* В нулевой байт отображения (который играет роль флага) пишем
		 * единицу - признак того, что в байт [1; 2047] записаны случайные символы */
		* ((char *) addr) = 1;
		
		/* Удаляем отображение */
		if(
				munmap(addr, 2048) == -1
		  )
			perror("Ошибка при удалении отображения");

		wait(NULL);		/* Ожидаем завершение дочернего процесса */

		unlink(name);	/* Удаляем файл */
	}
	else
	{
		/* Мы в дочернем процессе */

		/* Отображаем файл в память */
		addr = mmap(NULL, 2048, PROT_READ, MAP_SHARED, fd, 0);

		int old_errno = errno;	/* close() сбросит значение errno, а оно еще пригодиться */

		/* Закрываем дескриптор файла */
		close(fd);

		if(addr == MAP_FAILED)
		{
			fprintf(stderr, "Ошибка при отображении файла в память: %s\n", strerror(old_errno));

			return -1;
		}

		/* Ждем, пока первый байт не будет установлен в единицу */
		while(!(*((char *) addr)));

		printf("\n-------------------------------[Начало сообщения]-------------------------------\n");

		/* Выводим на экран байты [1; 2047] */
		for(x = 0; x < 2048; x++)
			printf("%c", ((char *) addr)[x]);

		printf("\n-------------------------------[Конец  сообщения]-------------------------------\n\n");

		/* Удаляем отображение */
		if(
				munmap(addr, 2048) == -1
		  )
			perror("Ошибка при удалении отображения");
	}

	return 0;
}

