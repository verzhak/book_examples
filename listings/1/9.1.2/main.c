
/* Программа суть есть пример использования:
 *		
 *		1. Функции sched_setscheduler(), используемой для установки политики планирования процесса и статического приоритета процесса
 *		2. Функции sched_setparam(), используемой для изменения статического приоритета процесса
 *		3. Функций sched_getscheduler() и sched_getparam(), используемые для получения информации о политике планирования целевого процесса и
 *		   о статическом приоритете целевого процесса соответственно
 *
 *	Алгоритм работы программы:
 *
 *		1. Явная привязка всех процессов программы к строго определенному процессору системы с помощью функции sched_setaffinity() -
 *		   необходимо для многопроцессорных и многоядерных систем для предотвращения распределения создаваемой процессами программы нагрузки
 *		2. Запуск UL_NUM бесполезных процессов, создающих нагрузку на процессор
 *		3. Создание начальной временной отметки
 *		4. Запуск полезного дочернего процесса (выполняет сортировку массива методом последовательного перебора - наилучший по времени
 *		   алгоритм сортировки (например, быстрая сортировка) нам не нужен, так как цель полезного дочернего процесса - создание достаточной нагрузки)
 *		5. Ожидание завершения полезного дочернего процесса
 *		6. Создание конечной временной отметки
 *		7. Подсчет времени, затраченного полезным дочерним процессом на выполнение
 *
 *		Пункты 3 - 7 повторяются для политик планирования SCHED_OTHER, SCHED_BATCH, SCHED_RR и SCHED_FIFO. Политика планирования SCHED_IDLE проигнорирована,
 *		так как ее особенность (выполнение процесса только в моменты полного бездействия системы) предусматривает либо длительное ожидание завершения
 *		полезного дочернего процесса, либо усложнение демонстрационной программы
 *
 *	Теоретические результаты:
 *
 *		Политики планирования SCHED_OTHER и SCHED_BATCH дадут самые большие временные показатели выполнения дочернего процесса,
 *		так как все побочные дочерние процессы имеют политику планирования SCHED_OTHER и, следовательно, будут наравне с полезным дочерним процессом
 *		участвовать в распределении процессорного времени
 *
 *		Политики планирования SCHED_RR и SCHED_FIFO дадут самые маленькие временные показатели выполнения дочернего процесса,
 *		так как побочные дочерние процессы принудительно уступят процессор полезному дочернему на все время его выполнения, за исключением промежутков
 *		его блокировки
 *
 *	Компиляция:
 *
 *		gcc -lrt main.c -o program.out
 *
 *		(ключ -l связывает с программой часть библиотеки glibc (rt), реализующую функцию clock_gettime(), используемую процессами программы
 *		для создания временных отметок)
 *
 *	Запуск:
 *
 *		su -c './program.out'
 *
 *		(запускать программу необходимо от имени суперпользователя, так как процессы, имеющие действительным владельцем суперпользователя, имеют характеристику
 *		CAP_SYS_NICE, необходимую для использования политик планирования SCHED_RR и SCHED_FIFO)
 */

#define _GNU_SOURCE			/* Для sched_setaffinity() */

#include <stdio.h>
#include <stdlib.h>

#include <time.h>			/* Для clock_gettime() и SCHED_BATCH (необязательно, если включен заголовочный файл <linux/sched.h>)*/
#include <unistd.h>			/* Для getpid() */
#include <sys/types.h>		/* Для waitpid() */
#include <sys/wait.h>
#include <sched.h>			/* Для sched_getscheduler(), sched_setscheduler(), sched_getparam(), sched_setparam() и sched_setaffinity() */
#include <linux/sched.h>	/* Для SCHED_BATCH и SCHED_IDLE */

/* Функция set_cpu() содержит в себе программный код, устанавливающий в качестве процессора, на котором исполняются все процессы программы,
 * первый процессор системы */
int set_cpu();

/* Функция run_good() запускает полезный дочерний процесс, устанавливает для него политику планирования policy и статический приоритет sched_priority,
 * после чего выполняет замер времени выполнения процесса и выводит полученные результаты */
void run_good(int policy, int sched_priority);

/* Функция good() содержит полезную нагрузку полезного дочернего процесса - сортировку методом последовательного перебора массива,
 * значения элементов которого сгенерированы случайно */
void good();

/* UL_NUM - количество побочный процессов, создающих бесполезную нагрузку на процессор */
#define UL_NUM 10

/* Функция ul() содержит бесполезную нагрузку бесполезных процессов */
void ul();

/* Главная функция программы */
int main()
{
	printf("\n");

	/* С помощью функции set_cpu() устанавливаем первый процессор системы как единственный,
	 * на котором должны выполнятся главный процесс программы и все его дочерние процессы */
	if(set_cpu() == -1)
	{
		perror("Ошибка при установке первого процессора системы единственным, на котором должны выполняться данный процесс и все его дочерние процессы");

		return -1;
	}

	int x, status, ul_pid[UL_NUM];

	/* Для каждого бесполезного дочернего процесса повторять... */
	for(x = 0; x < UL_NUM; x++)
		if(
			/* Запустить бесполезный дочерний процесс */
			(ul_pid[x] = fork()) == -1
		  )
			perror("Ошибка при создании бесполезного дочернего процесса");
		else if(!ul_pid[x])
		{
			/* Мы в очередном бесполезном дочернем процессе */

			/* Запускаем бесполезную нагрузку */
			ul();

			/* Завершаем бесполезный дочерний процесс с кодом возврата 0
			 *
			 * (так как бесполезная нагрузка организована с помощью бесконечного цикла,
			 * данная строка никогда не будет достигнута) */
			exit(0);
		}

	/* Мы в родительском процессе */

	printf("Полезный дочерний процесс:\n\n");
	
	/* Запускаем полезный дочерний процесс с политикой планирования SCHED_OTHER */
	run_good(SCHED_OTHER, 0);
	
	/* Запускаем полезный дочерний процесс с политикой планирования SCHED_BATCH */
	run_good(SCHED_BATCH, 0);

	/* Запуск полезного дочернего процесса с политикой планирования SCHED_IDLE пропускаем по причинам, изложенным выше */

	/* Запускаем полезный дочерний процесс с политикой планирования SCHED_RR и статическим приоритетом, равным 11 */
	run_good(SCHED_RR, 11);

	/* Запускаем полезный дочерний процесс с политикой планирования SCHED_FIFO и статическим приоритетом, равным 11 */
	run_good(SCHED_FIFO, 11);

	/* Замеры времени выполнения полезного дочернего процесса с разными политиками планирования и разными значениями
	 * статического приоритета закончены */

	/* Отправляем бесполезным дочерним процессам сигнал SIGKILL, предписывая, таким образом, ОС завершить все побочные дочерние процессы */
	for(x = 0; x < UL_NUM; x++)
		if(ul_pid[x] != -1)
			kill(ul_pid[x], SIGKILL);

	/* С помощью функции waitpid() последовательно дождемся завершения каждого из побочных дочерних процессов,
	 * проверяя при этом причину завершения - скорее всего, все побочные дочерние процессы будут завершены по сигналу
	 * SIGKILL - поэтому именно макрос WIFSIGNALED() первым вернет ненулевое значение */
	for(x = 0; x < UL_NUM; x++)
		if(ul_pid[x] != -1)
			do
				waitpid(ul_pid[x], & status, 0);
			while(! WIFEXITED(status) && ! WIFSIGNALED(status));

	return 0;
}

/* Функция set_cpu() содержит в себе программный код, устанавливающий в качестве процессора, на котором исполняются все процессы программы,
 * первый процессор системы */
int set_cpu()
{
	/* Переменная cpu_mask описывает маску процессоров, используемых процессами программы */
	cpu_set_t cpu_mask;

	/* Обнуляем маску */
	CPU_ZERO(& cpu_mask);

	/* Бит, отвечающий за первый процессор системы, устанавливаем в единицу */
	CPU_SET(0, & cpu_mask);

	/* Для данного процесса (первый параметр - 0) устанавливаем маску cpu_mask (третий параметр) размером в sizeof(cpu_mask) байт как
	 * маску используемых процессом процессоров системы. Все дочерние процессы данного процесса унаследуют данную маску */
	return sched_setaffinity(0, sizeof(cpu_mask), & cpu_mask);
}

/* Функция run_good() запускает полезный дочерний процесс, устанавливает для него политику планирования policy и статический приоритет sched_priority,
 * после чего выполняет замер времени выполнения процесса и выводит полученные результаты */
void run_good(int policy, int sched_priority)
{
	int good_pid, status;

	/* Запускаем полезный дочерний процесс */
	if(
		(good_pid = fork()) == -1
	  )
		perror("Ошибка при запуске полезного дочернего процесса");
	else if(good_pid)
		/* Мы в родительском процессе
		 *
		 * Ожидаем с помощью функции waitpid() завершение (макрос WIFEXITED() возвращает 1,
		 * если переданная ему информация о статусе процесса сообщает о произошедшем завершении процесса) запущенного
		 * дочернего процесса, PID которого передан в waitpid() в качестве первого параметра - good_pid */
		do
			waitpid(good_pid, & status, 0);
		while(! WIFEXITED(status));
	else
	{
		/* Мы в полезном дочернем процессе */

		/* Установим политику планирования и статический приоритет процесса */
		switch(policy)
		{
			case SCHED_OTHER:
				{
					/* Политика планирования SCHED_OTHER */

					struct sched_param sp;

					/* Статический приоритет не имеет смысла - устанавливаем его в ноль (функция sched_setscheduler()
					 * в случае SCHED_OTHER проигнорирует информацию о статическом приоритете) */
					sp.sched_priority = 0;

					/* Устанавливаем политику планирования полезного дочернего процесса - ею будет SCHED_OTHER */
					if(
						sched_setscheduler(0, SCHED_OTHER, & sp) == -1
					  )
						perror("Ошибка при установке политики планирования и статического приоритета полезного дочернего процесса");

					break;
				}

			case SCHED_BATCH:
				{
					/* Политика планирования SCHED_BATCH */

					struct sched_param sp;

					/* Статический приоритет не имеет смысла - устанавливаем его в ноль (функция sched_setscheduler()
					 * в случае SCHED_BATCH проигнорирует информацию о статическом приоритете) */
					sp.sched_priority = 0;

					/* Устанавливаем политику планирования полезного дочернего процесса - ею будет SCHED_BATCH */
					if(
						sched_setscheduler(0, SCHED_BATCH, & sp) == -1
					  )
						perror("Ошибка при установке политики планирования и статического приоритета полезного дочернего процесса");

					break;
				}

			case SCHED_IDLE:
				{
					/* Политика планирования SCHED_IDLE */

					struct sched_param sp;

					/* Статический приоритет не имеет смысла - устанавливаем его в ноль (функция sched_setscheduler()
					 * в случае SCHED_IDLE проигнорирует информацию о статическом приоритете) */
					sp.sched_priority = 0;

					/* Устанавливаем политику планирования полезного дочернего процесса - ею будет SCHED_IDLE */
					if(
						sched_setscheduler(0, SCHED_IDLE, & sp) == -1
					  )
						perror("Ошибка при установке политики планирования и статического приоритета полезного дочернего процесса");

					break;
				}

			case SCHED_RR:
				{
					/* Политика планирования SCHED_RR */

					struct sched_param sp;

					/* Новым значением статического приоритета процесса будет sched_priority */
					sp.sched_priority = sched_priority;

					/* Устанавливаем политику планирования полезного дочернего процесса (ею будет SCHED_RR)
					 * и новое значение статического приоритета (параметр sp) */
					if(
						sched_setscheduler(0, SCHED_RR, & sp) == -1
					  )
						perror("Ошибка при установке политики планирования и статического приоритета полезного дочернего процесса");

					break;
				}

			case SCHED_FIFO:
				{
					/* Политика планирования SCHED_FIFO */

					struct sched_param temp, sp;

					/* Новым значением статического приоритета процесса будет sched_priority */
					sp.sched_priority = sched_priority;

					/* Промежуточным значением статического приоритета процесса будет 17 */
					temp.sched_priority = 17;

					if(
						/* Устанавливаем политику планирования полезного дочернего процесса (ею будет SCHED_FIFO)
						 * и новое значение статического приоритета (параметр temp) */
						sched_setscheduler(0, SCHED_FIFO, & temp) == -1
						||
						/* Изменяем значение статического приоритета полезного дочернего процесса на значение,
						 * описанное параметром sp */
						sched_setparam(0, & sp) == -1
					  )
						perror("Ошибка при установке политики планирования и статического приоритета полезного дочернего процесса");

					break;
				}

			default:
				break;
		}

		struct sched_param sp;

		/* Получаем значение статического приоритета полезного дочернего процесса */
		if(
			sched_getparam(0, & sp) == -1
		  )
			perror("Ошибка при получении статического приоритета полезного дочернего процесса");
		
		printf("\tПолитика планирования: ");

		/* С помощью функции sched_getscheduler() получаем информацию о политике планирования полезного дочернего процесса
		 * и выводим информацию о ней и о статическом приоритете в стандартный поток вывода с помощью одного из вызовов функции printf() */
		switch(sched_getscheduler(0))
		{
			case SCHED_OTHER:
				{
					printf("SCHED_OTHER\n");
					break;
				}
			case SCHED_BATCH:
				{
					printf("SCHED_BATCH\n");
					break;
				}
			case SCHED_IDLE:
				{
					printf("SCHED_IDLE\n");
					break;
				}
			case SCHED_RR:
				{
					printf("SCHED_RR\n\tСтатический приоритет: %u\n", sp.sched_priority);
					break;
				}
			case SCHED_FIFO:
				{
					printf("SCHED_FIFO\n\tСтатический приоритет: %u\n", sp.sched_priority);
					break;
				}
			default:
				break;
		}

		struct timespec begin, end;

		/* Отмечаем начальную временную точку и сохраняем информацию о ней в переменной begin
		 *
		 * (CLOCK_MONOTONIC - монотонные общесистемные часы, отсчитывающие время не известно от какого момента времени в прошлом,
		 * но делающие это строго монотонно и гарантирующие, что будут также отсчитывать время и в будущем) */
		if(
			clock_gettime(CLOCK_MONOTONIC, & begin) == -1
		  )
			perror("Ошибка при получении стартовой временной отметки");

		/* Запускаем на выполнение полезную нагрузку полезного дочернего процесса */
		good();

		/* Отмечаем конечную временную точку и сохраняем информацию о ней в переменной end */
		if(
			clock_gettime(CLOCK_MONOTONIC, & end) == -1
		  )
			perror("Ошибка при получении конечной временной отметки");
		else
			/* Выводим в стандартный поток вывода время в секундах, затраченное полезным дочерним процессом на выполнение полезных действий
			 *
			 * Поля структуры данных timespec:
			 *
			 *		tv_sec - секунды
			 *		tv_nsec - наносекунды */
			printf("\tВремя выполнения: %.3f секунд\n\n", (end.tv_sec - begin.tv_sec) + (end.tv_nsec - begin.tv_nsec) / 1000000000.0);

		/* Завершаем полезный дочерний процесс с кодом завершения 0 */
		exit(0);
	}
}

/* Функция good() содержит полезную нагрузку полезного дочернего процесса - сортировку массива методом последовательного перебора его элементов */
void good()
{
#define ARRAY_SIZE 20480

	int x, y, min, temp, array[ARRAY_SIZE];

	/* Заполняем случайными целыми из диапазона [0; 255] массив размером в ARRAY_SIZE элементов */
	for(x = 0; x < ARRAY_SIZE; x++)
		array[x] = rand() % 256;

	/* Сортировка методом последовательного перебора */
	for(x = 0; x < ARRAY_SIZE; x++)
	{
		min = x;

		for(y = x + 1; y < ARRAY_SIZE; y++)
			if(array[min] > array[y])
				min = y;

		if(x != min)
		{
			temp = array[min];
			array[min] = array[x];
			array[x] = temp;
		}
	}
}

/* Функция ul() содержит бесполезную нагрузку бесполезных процессов */
void ul()
{
	int x;

	/* В качестве бесполезной нагрузки - бесконечный цикл */
	while(1)
		x++;
}

