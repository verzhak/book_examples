
/* Пример использования функций setsid(), getsid(), setpgid(), getpgid(), getpgrp() для создания новых сеансов и групп процессов,
 * перемещения процессов из одной группы в другую и получения SID и PGID сеансов и групп процессов, в которые входят вызывающие данные функции процессы
 *
 * Алгоритм работы программы:
 *
 *		1. Родительский процесс создает новый сеанс с помощью функции setsid() - в данном сеансе создается приоритетная группа,
 *		   в которой родительский процесс становится лидером
 *
 *		2. Родительский процесс запускает дочерний процесс. Дочерний процесс наследует SID и PGID родительского процесса -
 *		   то есть дочерний процесс будет принадлежать тому же сеансу и той же группе процессов, что и родительский процесс
 *
 *		   2.1 Дочерний процесс запускает 5 "внучатых" (по отношению к своему родительскому процессу - то есть дочерних по отношению к себе) процессов.
 *			   "Внучатые" процессы наследуют SID и PGID дочернего процесса => как и родительский и дочерний процессы, "внучатые" процессы будут
 *			   принадлежать приоритетной группе процессов сеанса, созданного в пункте 1
 *
 *		   2.2 Дочерний процесс создает новую фоновую (в сеансе, созданным родительским процессом) группу процессов, в которой становится лидером
 *
 *		   2.3 Дочерний процесс перемещает все "внучатые" процессы из приоритетной группы в только что созданную
 *
 *		   2.4 Дочерний процесс отправляет родительскому сигнал SIGUSR1
 *
 *		3. Родительский процесс, получив сигнал SIGUSR1, отправляет сигнал SIGTERM (ведущий к завершению получившего его процесса) всем процессам
 *		   группы дочернего процесса
 *
 *		   3.1 Дочерний процесс и "внучатые" процессы завершаются
 *
 *		4. Родительский процесс завершается
 */

#define _XOPEN_SOURCE 500	/* Для getsid() и getpgid() */

#include <stdio.h>
#include <stdlib.h>

#include <signal.h>			/* Для signal() и kill() */
#include <sys/types.h>
#include <sys/wait.h>		/* Для waitpid() */
#include <unistd.h>			/* Для setsid(), getsid(), setpgid(), getpgid() и getpgrp() */

/* Переменная child будет содержать PID дочернего процесса */
int child;

/* Функция - обработчик сигнала SIGUSR1 родительским процессом */
void SIGUSR1_proc(int notused)
{
	printf("\n---> Родительский процесс получил сигнал SIGUSR1 и отправляет процессам группы %d сигнал SIGTERM\n", child);

	/* Родительский процесс отправляет сигнал SIGTERM всем процессам из группы процессов с PGID === child
	 *
	 * (дочерний процесс является лидером целевой группы процессов => PGID данной группы процессов будет совпадать с PID дочернего процесса) */
	if(
		kill(- child, SIGTERM) == -1
	  )
	{
		perror("Ошибка при отправлении сигнала SIGTERM группе процессов");

		/* Родительский процесс предписывает ОС принудительно завершить дочерний и "внучатые" процессы, отправив данным процессам сигнал SIGKILL */
		kill(- child, SIGKILL);
	}
}

/* Функция - обработчик сигнала SIGTERM дочерним и "внучатыми" процессами */
void SIGTERM_proc(int notused)
{
	printf("\n\t---> Процесс [ SID == %d ] [ PGID == %d ] [ PID == %d ] получил сигнал SIGTERM и будет завершен\n",
			getsid(child), getpgid(child), getpid());

	/* Процесс, получивший сигнал SIGTERM, завершается с кодом завершения == 0 */
	exit(0);
}

/* Главная функция */
int main()
{
	/* Родительский процесс выводит в стандартный поток вывода свои:
	 *
	 *		SID		-	идентификатор сеанса, которому принадлежит процесс				-	с помощью функции getsid()
	 *		PGID	-	идентификатор группы процессов, которой принадлежит процесс		-	с помощью функции getpgid()
	 *		PID		-	собственный идентификатор										-	с помощью функции getpid()
	 */
	printf("\nРодительский процесс: [ SID == %d ] [ PGID == %d ] [ PID == %d ]\n", getsid(0), getpgid(0), getpid());

	printf("\n---> Родительский процесс создает новый сеанс, в котором становится лидером приоритетной группы процессов сеанса\n");

	/* Родительский процесс создает новый сеанс, лидером приоритетной группы которого родительский процесс и становится */
	if(
		setsid() == -1
	  )
		perror("Ошибка при создании нового сеанса");

	/* Родительский процесс снова выводит в стандартный поток вывода свои SID, PGID и PID */
	printf("\nРодительский процесс: [ SID == %d ] [ PGID == %d ] [ PID == %d ]\n", getsid(0), getpgid(0), getpgrp());

	printf("\n---> Родительский процесс запускает дочерний процесс\n");

	/* Родительский процесс запускает дочерний */
	if(
		(child = fork()) == -1
	  )
		perror("Ошибка при запуске дочернего процесса");
	else if(child)
	{
		/* Мы в родительском процессе */

		/* Родительский процесс устанавливает функцию - обработчик сигнала SIGUSR1 */
		if(
			signal(SIGUSR1, & SIGUSR1_proc) == SIG_ERR
		  )
			perror("Ошибка при установке обработчика сигнала SIGUSR1");
		else
		{
			/* Родительский процесс выводит в стандартный поток вывода SID, PGID и PID запущенного им дочернего процесса */
			printf("\nДочерний процесс: [ SID == %d ] [ PGID == %d ] [ PID == %d ]\n", getsid(child), getpgid(child), child);

			/* Родительский процесс ожидает завершения (макрос WIFEXITED()) или завершения по сигналу (макрос WIFSIGNALED()) дочернего процесса
			 *
			 * (выполнение функции waitpid() может быть (и будет) прервано по получении родительским процессом какого-либо не игнорируемого им сигнала
			 * (в данном случае будет получен сигнал SIGUSR1), но после обработки данного сигнала выполнение функции waitpid() будет возобновлено) */
			int status;
			do
				waitpid(child, & status, 0);
			while(! (WIFEXITED(status) || WIFSIGNALED(status)));

			/* Родительский процесс ожидает в течении секунды завершения всех своих "внучатых" процессов - действие абсолютно бесполезное с точки
			 * зрения алгоритма рассматриваемого примера, однако необходимое для организации более читабельного вывода информации, описывающей пример */
			sleep(1);
		}
	}
	else
	{
		/* Мы в дочернем процессе */

		/* Дочерний процесс ожидает в течении секунды вывода родительским процессом в стандартный поток вывода информации
		 * о SID, PGID и PID дочернего процесса - действие абсолютно бесполезное с точки зрения алгоритма рассматриваемого примера,
		 * однако необходимое для организации более читабельного вывода информации, описывающей пример */
		sleep(1);

		/* Дочерний процесс устанавливает функцию - обработчик сигнала SIGTERM
		 *
		 * (данную функцию - обработчик унаследуют также и "внучатые" процессы) */
		if(
			signal(SIGTERM, & SIGTERM_proc) == SIG_ERR
		  )
			perror("Ошибка при установке обработчика сигнала SIGTERM");
		else
		{
			printf("\n\t---> Дочерний процесс запускает 5 \"внучатых\" процессов\n");

			/* Дочерний процесс запускает 5 "внучатых" процессов */
			int x, dchild[5];
			for(x = 0; x < 5; x++)
				if(
					(dchild[x] = fork()) == -1
				  )
					perror("Ошибка при запуске дочернего процесса");
				else if(! dchild[x])
				{
					/* Мы в очередном "внучатом" процессе */

					/* Бесконечный цикл */
					while(1);

					/* Вызов функции exit() никогда не будет достигнут, так как "внучатый" процесс будет завершен ранее по получении им одного из сигналов:
					 * SIGTERM или SIGKILL */
					exit(0);
				}

			printf("\n\t---> Дочерний процесс создает новую группу процессов (в сеансе %d данная группа будет фоновой), в которой становится лидером\n",
					getsid(0));

			/* Дочерний процесс создает новую (фоновую для сеанса, созданного родительским процессом) группу процессов, в которой становится лидером */
			if(
				setpgid(0, 0) == -1
			  )
			{
				perror("Ошибка при создании новой группы процессов");

				/* Если создание новой группы процессов завершилось неудачей - дочерний процесс посылает сигналы SIGKILL всем "внучатым" процессам,
				 * тем самым предписывая ОС принудительно завершить данные процессы */
				for(x = 0; x < 5; x++)
					if(dchild[x] != -1)
						kill(dchild[x], SIGKILL);

				exit(-1);
			}
			else
			{
				/* Дочерний процесс выводит в стандартный поток вывода свои SID, PGID и PID */
				printf("\n\tДочерний процесс: [ SID == %d ] [ PGID == %d ] [ PID == %d ]\n", getsid(child), getpgid(child), getpid());

				for(x = 0; x < 5; x++)
				{
					/* Дочерний процесс перемещает "внучатые" процессы из приоритетной группы процессов в фоновую группу процессов,
					 * лидером которой является дочерний процесс */
					if(
						dchild[x] != -1
						&&
						setpgid(dchild[x], getpid()) == -1
					  )
						perror("Ошибка при изменении PGID дочернего процесса");
					else
						printf("\n\t\"Внучатый\" процесс: [ SID == %d ] [ PGID == %d ] [ PID == %d ]\n", getsid(dchild[x]), getpgid(dchild[x]), dchild[x]);
				}

				/* Дочерний процесс отправляет родительскому процессу сигнал SIGUSR1
				 *
				 * (PID родительского процесса дочерний процесс получает с помощью функции getppid()) */
				if(
					kill(getppid(), SIGUSR1) == -1
				  )
				{
					perror("Ошибка при отправлении родительском процессу сигнала SIGUSR1");

					/* Если дочерний процесс не смог отправить родительскому процессу сигнал SIGUSR1 - дочерний процесс посылает сигналы SIGKILL
					 * всем "внучатым" процессам, тем самым предписывая ОС принудительно завершить данные процессы */
					for(x = 0; x < 5; x++)
						if(dchild[x] != -1)
							kill(dchild[x], SIGKILL);

					exit(-1);
				}
			}

			/* Бесконечный цикл дочернего процесса */
			while(1);

			/* Вызов функции exit() никогда не будет достигнут, так как дочерний процесс будет завершен ранее по получении им одного из сигналов:
			 * SIGTERM или SIGKILL */
			exit(0);
		}
	}

	printf("\n");

	return 0;
}

