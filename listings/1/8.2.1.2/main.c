
/* Шифрование текста
 *
 * Открытый текст (ОТ) и шифротекст (ШТ) - последовательности латинских прописных букв
 *										   (пробелы, знаки препинания и прочие символы, не входящие в латинский алфавит, не допускаются)
 *
 * Алгоритм шифрования:
 *
 *		1. Каждой букве ОТ ставится в соответствие код - порядковый номер в латинском алфавите, считая с нуля
 *
 *		2. Текст делится на биграммы (пары букв; если букв нечетное количество, то справа к ОТ дописывается 'a'),
 *		   каждая пара букв получает свой собственный код P следующим образом:
 *			
 *			f(x, y) = P = (x * 26 + y) mod (26 * 26)
 *
 *			x - ASCII код левой буквы
 *			y - ASCII код правой буквы
 *
 *		3. Над ОТ выполняется шифрующее преобразование:
 *
 *			F(P) = C = (a * P * P + b * P) mod (26 * 26)
 *
 *		4. Шифрокод каждой биграммы разбивается на буквы ШТ:
 *
 *			g(C) = (x', y') = (C / 26, C - C / 26)
 *
 *			/ - целочисленное деление с округлением вниз
 *			x' - ASCII код левой буквы биграммы в ШТ
 *			y' - ASCII код правой буквы биграммы в ШТ
 *
 *	Ключ шифрования:
 *
 *		a, b - целые беззнаковые числа (в данной программе - 32-х разрядные)
 */

#include <stdio.h>

#include <stdint.h>		/* Для uint32_t и uint64_t */
#include <errno.h>		/* Для errno */
#include <stdlib.h>		/* Для realloc() */

/* M = 26 * 26 */
#define M 676

int main()
{
	printf("\n");

	char *cip_t = NULL, *open_t = NULL, *temp_open;
	size_t open_t_size, x;
	uint32_t a, b;
	uint64_t y;

	/* До тех пор, пока пользователь не введет нулевое значение размера ОТ, повторять... */
	do
	{
		/* Считываем размер ОТ */
		printf("Длина открытого текста > ");
		scanf("%u", & open_t_size);

		/* Если размер ОТ не ноль */
		if(open_t_size)
		{
			/* Если размер ОТ - нечетное, то увеличиваем размер ОТ на единицу */
			if(open_t_size % 2)
				open_t_size += 2 - open_t_size % 2;

			/* Предписываем ОС выделить области виртуального адресного пространства процесса под строки open_t - ОТ, cip_t - ШТ
			 *
			 * (на первой итерации open_t и cip_t равны NULL, поэтому произойдет выделение памяти,
			 * на последующих итерациях произойдет изменение размера строк с возможным перемещением их в памяти;
			 *
			 * размер строк - (open_t_size + 1) байт; дополнительный байт необходим для нулевого символа - признака конца строки, если размер строк -
			 *                четное число) */
			if(
				(open_t = (char *) realloc(open_t, open_t_size + 1)) == NULL
				||
				(cip_t = (char *) realloc(cip_t, open_t_size + 1)) == NULL
			  )
			{
				/* Выделение динамической памяти завершилось ошибкой */

				perror("Ошибка при выделении динамической памяти");

				open_t_size = 0;
			}
			else
			{
				/* Выделение динамической памяти завершилось успешно */

				/* Считываем ОТ */
				printf("Открытый текст > ");
				scanf("%s", open_t);

				/* Считываем a */
				printf("a > ");
				scanf("%u", & a);

				/* Считываем b */
				printf("b > ");
				scanf("%u", & b);

				/* Находим остаток a и b от деления на M - это допустимо, так как все прочие арифметические действия
				 * с участием a и b будут выполнятся по mod M, и необходимо, так как a и b - 32-х разрядные беззнаковые целые
				 * и поэтому могут вызвать переполнение 64-х разрядной временной переменной y при выполнении шифрующего преобразования,
				 * что повлечет за собой неверный результат данного преобразования */
				a %= M;
				b %= M;

				/* Находим коды символов ОТ - вычитаем ASCII код символа 'a' из ASCII кода каждого символа ОТ до тех пор,
				 * пока в ОТ не встретится признак конца строки - нулевой символ */
				for(temp_open = open_t; * temp_open; (*temp_open) -= 'a', temp_open++);

				/* Выполняем шифрование */
				for(x = 0; x < open_t_size; x += 2)
				{
					/* Находим код биграммы */
					y = 26 * open_t[x] + open_t[x + 1];

					/* Шифруем биграмму */
					y = (y * (a * y + b)) % M;
					
					/* Находим ASCII коды символов ШТ */
					cip_t[x] = y / 26;
					cip_t[x + 1] = y - 26UL * cip_t[x] + 'a';
					cip_t[x] += 'a';
				}

				/* Выводим в стандартный поток вывода ШТ */
				printf("Шифротекст > %s\n\n", cip_t);
			}
		}
	}
	while(open_t_size);

	/* Обнуляем errno, так как при освобождении памяти с помощью realloc() единственный способ узнать,
	 * завершилось ли освобождение памяти удачно, проверить, изменилось ли после вызова realloc() значение
	 * глобальной переменной errno */
	errno = 0;

	if(
		open_t != NULL
		&&
		/* Освобождаем память, на которую указывает open_t, передавая 0 в realloc() в качестве нового размера
		 * области виртуального адресного пространства процесса */
		realloc(open_t, 0) == NULL
		&&
		errno
	  )
		perror("Ошибка при освобождении области виртуального адресного пространства процесса");

	errno = 0;

	if(
		cip_t != NULL
		&&
		/* Освобождаем память, на которую указывает open_t, передавая 0 в realloc() в качестве нового размера
		 * области виртуального адресного пространства процесса */
		realloc(cip_t, 0) == NULL
		&&
		errno
	  )
		perror("Ошибка при освобождении области виртуального адресного пространства процесса");

	printf("\n");

	return 0;
}

