
/* Алгоритм работы программы:
 *
 *		1. Явная привязка всех процессов программы к строго определенному процессору системы с помощью функции sched_setaffinity() -
 *		   необходимо для многопроцессорных и многоядерных систем для предотвращения распределения создаваемой процессами программы нагрузки
 *		2. Запуск UL_NUM бесполезных процессов, создающих нагрузку на процессор
 *		3. Изменение любезности главного процесса программы на произвольное целое
 *		4. Создание начальной временной отметки
 *		5. Выполнение главным процессом полезных действий - вычисление CRC-32 для произвольного текста
 *		6. Создание конечной временной отметки
 *		7. Подсчет времени, затраченного главным процессом на выполнение полезных действий
 *
 *		Пункты 3 - 7 повторяются для различных значений любезности главного процесса
 *
 *	Процессами программы используется политика планирования SCHED_OTHER (политика планирования по умолчанию),
 *	подразумевающая распределение процессорного времени с помощью значений любезности
 *	
 *	Теоретические результаты:
 *
 *		Должна быть отслежена следующая зависимость: с увеличением любезности главного процесса увеличивается время выполнения им полезных действий
 *	
 *	Компиляция:
 *
 *		gcc -lrt -lm main.c -o program.out
 *
 *		Ключ -l связывает с программой часть библиотеки glibc (rt), реализующую функцию clock_gettime(),
 *		используемую главным процессом программы для создания временных отметок
 *
 *	Запуск:
 *
 *		su -c './program.out'
 *
 *		(запускать программу необходимо от имени суперпользователя, так как процессы, имеющие действительным владельцем суперпользователя, имеют характеристику
 *		CAP_SYS_NICE, необходимую для использования отрицательных значений любезности)
 */

#define _GNU_SOURCE			/* Для sched_setaffinity() */

#include <stdio.h>
#include <stdint.h>

#include <sys/mman.h>		/* Для mmap() и munmap() */
#include <sched.h>			/* Для sched_setaffinity() */
#include <time.h>			/* Для clock_gettime() */
#include <signal.h>			/* Для kill() */
#include <sys/wait.h>		/* Для waitpid(), WIFEXITED и WIFSIGNALED */
#include <sys/types.h>		/* Для fork() */
#include <errno.h>			/* Для errno */
#include <unistd.h>			/* Для nice() */

/* Функция set_cpu() содержит в себе программный код, устанавливающий в качестве процессора, на котором исполняются все процессы программы,
 * первый процессор системы */
int set_cpu();

/* Функция good() содержит полезную нагрузку главного процесса - вычисление CRC-32 для произвольного текста */
void good();

/* UL_NUM - количество побочный процессов, создающих бесполезную нагрузку на процессор */
#define UL_NUM 15

/* Функция ul() содержит бесполезную нагрузку бесполезных процессов */
void ul();

int main()
{
	printf("\n");

	/* С помощью функции set_cpu() устанавливаем первый процессор системы как единственный,
	 * на котором должны выполнятся главный процесс программы и все его дочерние процессы */
	if(set_cpu() == -1)
	{
		perror("Ошибка при установке первого процессора системы единственным, на котором должны выполняться данный процесс и все его дочерние процессы");

		return -1;
	}

	int x, status, ul_pid[UL_NUM];

	/* Для каждого бесполезного дочернего процесса повторять... */
	for(x = 0; x < UL_NUM; x++)
		if(
			/* Запустить бесполезный дочерний процесс */
			(ul_pid[x] = fork()) == -1
		  )
			perror("Ошибка при запуске бесполезного дочернего процесса");
		else if(! ul_pid[x])
		{
			/* Мы в очередном бесполезном дочернем процессе */

			/* Запускаем бесполезную нагрузку */
			ul();

			/* Завершаем бесполезный дочерний процесс с кодом возврата 0
			 *
			 * (так как бесполезная нагрузка организована с помощью бесконечного цикла,
			 * данная строка никогда не будет достигнута) */
			exit(0);
		}

	/* Мы в родительском (главном) процессе */

	printf("Главный процесс:\n\n");

	int nice_value;
	struct timespec begin, end;

	for(x = 0; x < 7; x++)
	{
		/* Обнуляем переменную errno
		 *
		 * Если значение errno не изменится после вызова функции nice(), то это будет означать,
		 * что данная функция завершилась успешно - надеяться на возврат nice() -1 только в случае ошибки некорректно,
		 * так как данная функция может вернуть -1 и в случае успеха - в том случае, если значение любезности процесса равно -1 */ 
		errno = 0;

		/* Отмечаем начальную временную точку и сохраняем информацию о ней в переменной begin
		 *
		 * (CLOCK_MONOTONIC - монотонные общесистемные часы, отсчитывающие время не известно от какого момента времени в прошлом,
		 * но делающие это строго монотонно и гарантирующие, что будут также отсчитывать время и в будущем) */
		if(
			clock_gettime(CLOCK_MONOTONIC, & begin) == -1
		  )
			perror("Ошибка при создании начальной временной отметки");
		/* С помощью функции nice() случайным образом изменяем значение любезности вызвавшего nice() процесса
		 * (главного процесса программы) на значение, переданное nice() в качестве параметра.
		 * Функция nice() возвращает значение любезности процесса */
		else if(
				(nice_value = nice((rand() % 2 ? -1 : 1) * x + rand() % 7 - 5)) == -1
				&&
				errno
			   )
			perror("Ошибка при изменении значения любезности главного процесса");
		else
		{
			/* Выводим в стандартный поток вывода текущее значение любезности главного процесса */
			printf("\tЛюбезность: %d\n", nice_value);

			/* Запускаем на выполнение полезную нагрузку главного процесса */
			good();

			/* Отмечаем конечную временную точку и сохраняем информацию о ней в переменной end */
			if(
				clock_gettime(CLOCK_MONOTONIC, & end) == -1
			  )
				perror("Ошибка при создании конечной временной отметки");
			else
				/* Выводим в стандартный поток вывода время в секундах, затраченное главным процессом на выполнение полезных действий
				 *
				 * Поля структуры данных timespec:
				 *
				 *		tv_sec - секунды
				 *		tv_nsec - наносекунды */
				printf("\tВремя выполнения: %.3f секунд\n\n", (end.tv_sec - begin.tv_sec) + (end.tv_nsec - begin.tv_nsec) / 1000000000.0);
		}
	}

	/* Отправляем бесполезным дочерним процессам сигнал SIGKILL, предписывая, таким образом, ОС завершить все побочные дочерние процессы */
	for(x = 0; x < UL_NUM; x++)
		if(ul_pid[x] != -1)
			kill(ul_pid[x], SIGKILL);

	/* С помощью функции waitpid() последовательно дождемся завершения каждого из побочных дочерних процессов,
	 * проверяя при этом причину завершения - скорее всего, все побочные дочерние процессы будут завершены по сигналу
	 * SIGKILL - поэтому именно макрос WIFSIGNALED() первым вернет ненулевое значение */
	for(x = 0; x < UL_NUM; x++)
		if(ul_pid[x] != -1)
			do
				waitpid(ul_pid[x], & status, 0);
			while (! WIFEXITED(status) && ! WIFSIGNALED(status));

	return 0;
}

/* Функция set_cpu() содержит в себе программный код, устанавливающий в качестве процессора, на котором исполняются все процессы программы,
 * первый процессор системы */
int set_cpu()
{
	/* Переменная cpu_mask описывает маску процессоров, используемых процессами программы */
	cpu_set_t cpu_mask;

	/* Обнуляем маску */
	CPU_ZERO(& cpu_mask);

	/* Бит, отвечающий за первый процессор системы, устанавливаем в единицу */
	CPU_SET(0, & cpu_mask);

	/* Для данного процесса (первый параметр - 0) устанавливаем маску cpu_mask (третий параметр) размером в sizeof(cpu_mask) байт как
	 * маску используемых процессом процессоров системы. Все дочерние процессы данного процесса унаследуют данную маску */
	return sched_setaffinity(0, sizeof(cpu_mask), & cpu_mask);
}

/* Функция good() содержит полезную нагрузку главного процесса - вычисление CRC-32 для произвольного текста */
void good()
{
	/* Размер текста - 5 мегабайт */
#define BUF_LEN (1048576 * 5)

	/* Выделение памяти для текстового буфера путем создания анонимного (MAP_ANONYMOUS) неразделяемого (MAP_PRIVATE) отображения */
	unsigned char *real_buf = (unsigned char *) mmap(NULL, BUF_LEN, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

	if(real_buf != MAP_FAILED)
	{
		unsigned char *buf = real_buf;
		uint16_t x, y;
		uint32_t crc, crc_table[256], buf_len = BUF_LEN;

		/* Генерация произвольного текста */
		while (buf_len--)
			buf[buf_len] = rand() % 256;

		/* Подсчет CRC-32 */

		buf_len = BUF_LEN;

		for(x = 0; x < 256; x++)
		{
			crc = x;

			for(y = 0; y < 8; y++)
				if(crc & 1)
					crc = (crc >> 1) ^ 0xEDB88320UL;
				else
					crc >>= 1;
	 
			crc_table[x] = crc;
		};
 
		crc = 0xFFFFFFFFUL;
	 
		while (buf_len--) 
			crc = crc_table[(crc ^ *buf++) & 0xFF] ^ (crc >> 8);
 
		crc ^= 0xFFFFFFFFUL;

		/* Удаление анонимного отображения */
		munmap(real_buf, BUF_LEN);
	}
}

/* Функция ul() содержит бесполезную нагрузку бесполезных процессов */
void ul()
{
	int x;

	/* В качестве бесполезной нагрузки - бесконечный цикл */
	while(1)
		x++;
}

